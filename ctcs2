#!/usr/bin/perl -wT
###############################################################################
#
=pod

=head1 NAME

ctcs2

=head1 SYNOPSIS

ctcs2 [--download=1000] [--upload=50] [--port=8080] [--no-log-times] [--help]

=head1 DESCRIPTION

A replacement for the CTorrent Control Center
(http://www.rahul.net/dholmes/ctorrent/ctcs.html) that aims for clean code and
simple extensibility.

Many thanks to Dennis Holmes for the original CTCS code, which was used
extensively during development as a protocol reference.

=head1 COMMAND LINE OPTIONS

=over

=item --download

Sets the download limit used by the server, in KB/s.  Can be changed later
from the Web UI.  Defaults to 1000.

=item --upload

Sets the upload limit used by the server, in KB/s.  Can be changed later
from the Web UI.  Defaults to 50.

=item --port

Sets the port to listen on for ctorrent/Web connections.  Defaults to 8080

=item --no-log-times

Suppresses the printing of timestamps on log messages.  This is useful when
using CTCS2 with an external logging mechanism like daemontools' multilog, where
timestamps are automatically prepended to log lines.  Defaults to off (log
messages are timestamped)

=back

=head1 AUTHOR

Danny Woods (dannywoodz@yahoo.co.uk)

=head1 COPYRIGHT

Copyright (c) 2009-2010 Danny Woods

=head1 LICENCE

BSD

=cut
#
###############################################################################

use IO::Socket qw($CRLF AF_INET SOMAXCONN SOCK_STREAM);
use IO::Select;
use IO::Handle;
use Scalar::Util;
use Socket 'TCP_NODELAY';
use Errno 'EAGAIN';
use MIME::Base64;
use CGI qw(:standard);
use Getopt::Long;
use POSIX qw(strftime);
use Fcntl qw(SEEK_CUR SEEK_SET);
use strict;
use warnings;
use diagnostics;
use constant LOG_DEBUG     => [1, 'DEBUG'];
use constant LOG_INFO      => [2, 'INFO'];
use constant LOG_WARNING   => [3, 'WARNING'];
use constant LOG_ERROR     => [4, 'ERROR'];
use constant LOG_ALWAYS    => [10,'ALWAYS'];
use constant LOG_MIN       => 1;
use constant LOG_MAX       => 4;
use constant SUMMARY_BRIEF => 1;
use constant SUMMARY_FULL  => 2;
use constant FORM_ENCODING => 'application/x-www-form-urlencoded';

$0         = 'ctcs2';
STDOUT->autoflush(1);

my $port                      = 8080;
my $download_limit            = 1000;
my $upload_limit              = 50;
my $suppress_log_timestamps   = 0;
my $current_id                = 1;
my $help                      = undef;
my $update_connected_torrents = 1;

$SIG{INT}   = \&cleanup;
$SIG{TERM}  = \&cleanup;
$SIG{PIPE}  = 'IGNORE';


###############################################################################
# The core data structures used by the server.
# %clients is a hash of hashes that contains information about clients, whether
# they are web browsers or ctorrent instances.  The keys are the socket
# instances themselves.  The values are sub-hashes.
#
# A typical clients hash might look like this:
#
# %clients{$socket}->{torrent}->{ctorrent_id}
#                             ->{ctcs_id}
#                             ->{name}
#                             ->{upload_rate}
#                             ->{download_rate}
#                             ->{size}
#                             ->{piece_size}
#                             ->{active_seeders}
#                             ->{total_seeders}
#                             ->{active_leechers}
#                             ->{total_leechers}
#                             ->{total_connections}
#                             ->{downloaded_chunks}
#                             ->{total_chunks}
#                             ->{available_chunks}
#                             ->{downloaded}
#                             ->{uploaded}
#                             ->{download_limit}
#                             ->{upload_limit}
#                             ->{cache_used}
#                             ->{last_status_update}
#                             ->{files}->[$n]->{name}
#                                            ->{size}
#                             ->{peers}->[$n]->{id}
#                                            ->{address}
#                                            ->{remote_flags}
#                                            ->{local_flags}
#                                            ->{download_rate}
#                                            ->{upload_rate}
#                                            ->{downloaded}
#                                            ->{uploaded}
#                                            ->{pieces}
#                             ->{config}->{$field}->{value}
#                                                 ->{type}
#                                                 ->{range}
#                                                 ->{short_desc}
#                                                 ->{long_desc}
#
#                  ->{address}
#                  ->{messages}->[ writer-function-1 ... writer-function-n ]
#
# Web clients don't have the 'torrent' subhash: that is only available for
# ctorrent clients.
#
# %ctcs contains information about the server: global upload limit, download
# limit, uptime, etc.  This information is relevant to the server, and NOT
# any individual torrent.
#
# Occasionally, it's useful to find a client socket using the torrent name:
# it's very tempting at this point to add another hash that has this mapping,
# but really, the cost of searching is minimal, and not worth the additional
# headaches of making sure that everything's correctly cleaned up.  The good
# thing about this structure is that when a socket is closed, it's just
# a matter of deleting it from the %clients hash to get rid of all associated
# information.
###############################################################################

my %clients;
my %ctcs;
my $favicon;

###############################################################################
# Command-line options
###############################################################################

GetOptions('port=i'       => \$port,
           'download=i'   => \$download_limit,
           'upload=i'     => \$upload_limit,
           'no-log-times' => \$suppress_log_timestamps,
           'help'         => \$help);

###############################################################################
# Usage
###############################################################################

if ($help)
{
  eval "use Pod::Text;";
  pod2text($0);
  exit(0);
}

###############################################################################
# The server socket, and activity handles to be used later in a select call.
###############################################################################

my $server = IO::Socket::INET->new(LocalPort => $port,
                                   ReuseAddr => 1,
                                   Type      => SOCK_STREAM,
                                   Blocking  => 0,
                                   Proto     => 'tcp',
                                   Listen    => SOMAXCONN) || die $!;

my $readers  = IO::Select->new($server);
my $writers  = IO::Select->new();
my $errors   = IO::Select->new();

###############################################################################
# Setup defaults for the server
###############################################################################

$ctcs{download_limit}       = $download_limit * 1024;
$ctcs{upload_limit}         = $upload_limit * 1024;
$ctcs{accepted_connections} = 0;
$ctcs{closed_connections}   = 0;
$ctcs{port}                 = $port;
$ctcs{log_timestamps}       = !$suppress_log_timestamps;
$ctcs{log_level}            = LOG_INFO->[0];
$ctcs{log_file_handle}      = \*STDOUT;
$ctcs{auto_refresh}         = 1;

###############################################################################
# Setup the API.
###############################################################################

setup_api(\%ctcs);
setup_favicon(\$favicon);

ctcs_log(LOG_INFO, 'CTCS Server started on port %d', $port);

###############################################################################
# Main loop
###############################################################################

for (my ($last_update, $now) = (time(), time()); defined($server); $now = time())
{
  my ($readable, $writable, $errored) = IO::Select::select($readers, $writers, $errors, 1);

  handle_error($_) for @$errored;
  handle_write($_) for @$writable;
  handle_read($_)  for @$readable;

  if ($now > $last_update + 4)
  {
    foreach my $client (torrent_clients())
    {
      my $torrent = torrent_handled_by($client);
      unless(torrent_is_paused($torrent))
      {
        torrent_update_detail($client);
        torrent_update_status($client);
        torrent_update_peers($client);
        torrent_update_config($client);
      }
      ctcs_update_bandwidth_allocation();
    }
    $last_update = $now;
  }
}

cleanup();
exit(0);

###############################################################################
# Subroutines
###############################################################################

sub cleanup
{
  if ($server)
  {
    ctcs_log(LOG_INFO, 'Cleaning up');
    $readers->remove($server);
    $server->close();
    undef $server;
  }
}

###############################################################################
# There's nothing special required for errored clients: just get rid of them
###############################################################################

sub handle_error
{
  deregister_client(shift);
}

###############################################################################
# A read event is triggered by two things: when it appears on the server
# socket, it means that a new client is asking for permission to connect.
# Being triggered by any other socket means that it's a client socket sending
# a message
###############################################################################

sub handle_read
{
  my $socket = shift;
  return unless defined $server;
  if ($socket == $server)       # New client connection
  {
    register_new_client($socket->accept());
    $ctcs{accepted_connections}++;
  }
  else                          # Incoming data on a client handle
  {
    handle_request($socket);
  }
}

###############################################################################
# A new client gets a slot in the %clients hash, with an empty queue.  They
# are then added to the readers list so that a future select will reap their
# request.
###############################################################################

sub register_new_client
{
  my $client = shift;

  $client->sockopt(TCP_NODELAY, 1);
  $client->blocking(0);

  $clients{$client} = {};
  $clients{$client}->{messages} = [];
  $clients{$client}->{socket}   = $client;

  ctcs_log(LOG_INFO,
           'connection from %s:%d',
           address_of($client),
           $client->peerport());

  $readers->add($client);
}

###############################################################################
# Cleans up the resources associated with a given socket.
###############################################################################

sub deregister_client
{
  my $client   = shift;

  return if !exists($clients{$client});

  my $hostname = $client->opened() ? address_of($client) : 'CLOSED';
  my $port     = $client->opened() ? $client->peerport() : -1;
  if (exists($clients{$client}) &&
      exists($clients{$client}->{messages}) &&
      scalar @{$clients{$client}->{messages}} > 0)
  {
    ctcs_log(LOG_WARNING, 'Client being deleted with a non-empty message queue');
    my $string = '';
    my $handle = IO::Handle->new();
    if (open($handle, '>', \$string))
    {
      $_->($handle) for @{$clients{$client}->{messages}};
      close($handle);
    }
    ctcs_log(LOG_WARNING, $string);
  }

  #############################################################################
  # There's a small memory problem with the validator functions attached to
  # config elements.  Specifically, each validator is attached to an element,
  # but is also a closure that refers to that element.  This creates a cycle
  # in the memory graph that Perl's reference counting garbage collector
  # can't deal with.  The solution is to explicitly break the cycle.  This
  # is acheived by de-scoping the validator function prior to the configuration
  # element being deleted.
  #############################################################################

  if (exists($clients{$client}->{torrent}) &&
      exists($clients{$client}->{torrent}->{config}))
  {
    my $config = $clients{$client}->{torrent}->{config};
    ($config->{$_}->{validator} = undef) for keys %$config;
  }

  delete $clients{$client};
  ctcs_log(LOG_INFO,
           'connection closed%s',
           (defined($hostname)) ? " from $hostname:$port" : '');
  $readers->remove($client) while $readers->exists($client);
  $writers->remove($client) while $writers->exists($client);

  return unless $client->opened();

  $client->close();
  $ctcs{closed_connections}++;
}

###############################################################################
# A new client request can be triggered by one of two things: the client
# closing or actually presenting data on the wire to be read.  In the latter
# case, the client is added as a writer for a future select, and a *function*
# that will supply what to write is added to its message queue.
# If the event was triggered by client closure, nothing will be read from the
# underlying socket, so the clients can be removed from the readers list,
# its message queue destroyed and then be explicitly closed.
###############################################################################

sub handle_request
{
  my $client = shift;
  my $reader = reader_function_for($client);
  my $message = $reader->($client);

  if ($message)
  {
    chomp($message);
    ctcs_log(LOG_DEBUG, q(Message from %s: '%s'), address_of($client), $message);
    eval {
      my $function = function_to_handle_request($message, $client);
      send_message_function($function, $client) if $function;
    };
    ctcs_log(LOG_WARNING, $@) if $@;
  }
  else
  {
    if ($! == EAGAIN)
    {
      ctcs_log(LOG_DEBUG, 'EAGAIN is set: will handle request later');
      $! = 0;
    }
    else
    {
      my $torrent = $clients{$client}->{torrent};
      deregister_client($client);
      autobalance_bandwidth() if $torrent;
    }
  }
}

###############################################################################
# name:        reader_function_for
# description: Returns a function that, when called against a given socket,
#              will return that socket's request. If the request is a simple
#              HTTP GET or ctorrent CTBW, etc., the return value is a single
#              line.  POSTs are returned in their entirety.
#              In any event, if the request cannot be read fully, this function
#              returns undef.  If it's simply an exhausted buffer, $! is set to
#              EAGAIN.  It can be called repeatedly against the same socket
#              until it either returns the message, or undef with $! != EAGAIN
# returns:     a function that should be invoked with an IO::Handle object
#              (most likely a socket)
###############################################################################

sub reader_function_for
{
  my ($socket) = @_;
  my $function = $clients{$socket}->{reader};
  if (!$function)
  {
    my $header = IO::Handle->new();
    my $header_string = '';
    my $header_read;
    my $content_length;
    my $body;
    my $line_reader = line_reader_function();
    my $do_initialise = 1;

    open($header, '>', \$header_string) || die $!;

    my $initialise = sub {
      ctcs_log(LOG_DEBUG, 'Initialising reader function');
      seek($header, 0, SEEK_SET);
      $header_read    = 0;
      $content_length = 0;
      $body = '';
      $do_initialise = 0;
    };

    $function = $clients{$socket}->{reader} = sub {
      my $client = $_[0];
      my ($line, $result);

      $initialise->() if $do_initialise;

      while (!$header_read && defined($line = $line_reader->($client)))
      {
        return $line if $line !~ /^(?:POST|GET)/ && tell($header) == 0;
        $content_length = $1 if $line =~ /^Content-Length: (\d+)/;
        ctcs_log(LOG_DEBUG, q(Header line: '%s'), $line);
        print $header $line, "\n";
        $header_read = 1 if $line eq '';
      }
      return undef unless $header_read;

      ctcs_log(LOG_DEBUG, 'Content-Length: %s', $content_length);
      ctcs_log(LOG_DEBUG, 'BEFORE: Length of body is %d', length($body));

      while ($content_length > 0 &&
             length($body) < $content_length &&
             defined($result = $line_reader->($client, $content_length))) {
        last unless $result;
        $body = $result;
      }

      ctcs_log(LOG_DEBUG, 'AFTER: Length of body is %d', length($body));
      ctcs_log(LOG_DEBUG, q(Body is '%s'), $body);

      return undef if (!defined($result) && length($body) < $content_length);
      return undef unless length($body) == $content_length;

      ctcs_log(LOG_DEBUG, 'Body: %s', $body);

      print $header $body if $body;

      $do_initialise = 1;

      return $header_string;
    }
  }
  return $function;
}

###############################################################################
# name:        writer_function
# description: returns a function that, when given an IO handle, will write
#              the return value of the function given to writer_function onto
#              it (pause and think about that for a second: I definitely needed
#              to).  The function returned will return a false value if it
#              hasn't written the entire message, or a true value if it has.
# params:      a reference to a function whose return value should be fed into
#              the function returned by this function.
# returns:     a function that takes an IO handle
###############################################################################

sub writer_function
{
  my $handler = shift;
  my $close_after_write = shift;
  my $message = undef;
  my $message_length = 0;
  my $message_offset = 0;
  return sub {

    if (!$message)
    {
      $message = $handler->();
      return 1 unless defined $message;
      $message_length = length($message);
      $message_offset = 0;
    }

    my $client  = shift;

    ctcs_log(LOG_DEBUG, 'Writing %d bytes of length %d, starting at %d',
             $message_length - $message_offset, $message_length,
             $message_offset);

    my $written = syswrite($client,
                           $message,
                           $message_length - $message_offset,
                           $message_offset);
    if (!defined($written))
    {
      ctcs_log(LOG_WARNING,
               q(Failed to write message '%s', starting at index %d),
               $message,
               $message_length - $message_offset);
      return 1; # The message is effectively finished if it has errored
    }

    ctcs_log(LOG_DEBUG, 'Wrote %d bytes of a %d byte message',
             $written, $message_length);

    $message_offset += $written;
    my $finished = ($message_offset == $message_length);

    ctcs_log(LOG_DEBUG,
             'Wrote %d bytes, leaving %d remaining. Message is%s finished',
             $written, $message_length - $message_offset, $finished ? '' : ' NOT');

    if ($close_after_write && $finished)
    {
      shift(@{$clients{$client}->{messages}});
      deregister_client($client);
    }

    return $finished;
  }
}

###############################################################################
# Writing is simple: for a given socket, it has a queue of functions in the
# 'messages' subhash.  Each of these functions will return true if they finish
# sending, and false otherwise.  Each function should be a writer_function that
# wraps a content generating function: the writer function keeps track of how
# much of a given message that it has sent, so it needn't be tracked here.
###############################################################################

sub handle_write
{
  my $client = shift;
  my $messages = $clients{$client}->{messages};

  while ($messages && @$messages)
  {
    my $function = $messages->[0];
    last if !$function->($client);
    shift(@$messages);
  }
  $writers->remove($client) unless ($messages && @$messages);
}

###############################################################################
# This is the big decision maker: given a message, it needs to return a
# writer_function that wraps some content generating function.  The content
# generating function needs to return a string.
###############################################################################

sub function_to_handle_request
{
  my ($message, $client) = @_;
  my ($command, $params);

  ($command, $params) = split(' ', $message, 2);

  if ($command eq 'CTBW')
  {
    $params =~ m/(\d+),\s*(\d+)\s+(?:\d+),\s*(?:\d+)/;
    record_bandwidth($client, $1, $2);
  }
  elsif ($command eq 'CTPEER')
  {
    torrent_add_peer(torrent_handled_by($client), $params);
  }
  elsif ($command eq 'CTCONFIG')
  {
    torrent_store_config(torrent_handled_by($client), $params);
  }
  elsif ($command eq 'CTFILE')
  {
    torrent_populate_file_info(torrent_handled_by($client), $params);
  }
  elsif ($command eq 'CTPEERSTART')
  {
    $clients{$client}->{torrent}->{incoming_peers} = [];
  }
  elsif ($command eq 'CTPEERSDONE')
  {
    my $torrent = torrent_handled_by($client);
    ctcs_log(LOG_INFO, q(Received %d peers for '%s'),
             peer_count_for($client),
             $torrent->{name});
    $torrent->{peers} = $torrent->{incoming_peers};
    delete $torrent->{incoming_peers};
    $torrent->{last_peers_update} = time();
  }
  elsif ($command eq 'CTSTATUS')
  {
    my $torrent_info = torrent_handled_by($client);
    torrent_set_status($torrent_info, $params);
    return exists($torrent_info->{size}) ?
    undef :
      writer_function(\&ctcs_request_detail_command);
  }
  elsif ($command eq 'CTDETAIL')
  {
    $params =~ m/(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/;
    my $torrent_info = torrent_handled_by($client);
    $torrent_info->{size}       = $1;
    $torrent_info->{piece_size} = $2;
    $torrent_info->{time_now}   = $3;
    $torrent_info->{time_seed}  = $4;
  }
  elsif ($command eq 'CTORRENT')
  {
    $params =~ m/([^\s]+)(?:\s+(\d+)\s+(\d+)\s+(.*))?/;
    handle_register_torrent($client, $1, $2, $3, $4);
    autobalance_bandwidth();
    return writer_function( sub { ctcs_protocol() . $CRLF });
  }
  elsif ($command eq 'GET')
  {
    $params =~ m/^([^\s]+)/;
    my $target = $1;
    my $close_after_write = $message =~ /Connection: close/i;
    return writer_function(sub { handle_send_page($target, $client) }, $close_after_write);
  }
  elsif ($command eq 'POST')
  {
    $params =~ m/([^\s]+)/;
    my $target = $1;
    return writer_function(sub { handle_form_submission($target, $client, $message)}, 1);
  }
  elsif ($command eq 'DUMP')
  {
    return writer_function(\&handle_dump);
  }
  elsif ($command eq 'PROTOCOL')
  {
    $params =~ m/0*(\d+)/;
    $ctcs{protocol} = $1;
  }
  elsif ($command eq 'CTFILESDONE'   ||
         $command eq 'CTFILESTART'   ||
         $command eq 'CTCONFIGSTART' ||
         $command eq 'CTCONFIGDONE'  ||
         $command eq 'CTINFO')
  {
    # Nothing: just here to avoid triggering the following exception
  }
  else
  {
    die "No function to handle request '$message'\n";
  }
  return undef;
}

###############################################################################
# This is a simple convenience utility.  Given a block of code, any 'print'
# or 'write' statements *not* directed at a specific filehandle will instead
# be collected in a string that is returned when the function completes.
###############################################################################

sub with_output_to_string(&)
{
  my $function = shift;
  my $string = '';
  my $handle;
  open($handle, '>', \$string) || die $!;
  my $oldfd = select $handle;
  eval { $function->() };
  close($handle);
  select $oldfd;
  warn if $@;
  return $string;
}

###############################################################################
# Given a location, this function should return a string that represents the
# content of that location
###############################################################################

sub handle_send_page
{
  my ($location, $client) = @_;
  my $response_code;
  my $page = page_content($location);

  if ( defined($page) )
  {
    $response_code = '200 OK';
  }
  else
  {
    $page = with_output_to_string {
      print start_html({title => 'CTCS 2 - Page Not Found'}),
      error_page($location),
      end_html();
    };
    $response_code = '404 Not Found';
  }

  return join('',
              ("HTTP/1.1 $response_code\r\n",
               header({content_length => length($page)}),
               $page));
}

sub handle_form_submission
{
  my ($target, $client, $request) = @_;
  my $handle = IO::Handle->new();
  open($handle, '<', \$request) || die $!;
  my $query = CGI->new($handle);

  ctcs_log(LOG_DEBUG, $request);

  if ($target eq '/')
  {
    my $upload_limit              =  $query->param('ulimit');
    my $download_limit            =  $query->param('dlimit');
    my $auto_refresh              =  $query->param('auto-refresh');
    $ctcs{download_limit}         =  (int($download_limit) * 1024) if defined $download_limit;
    $ctcs{upload_limit}           =  (int($upload_limit) * 1024) if defined $upload_limit;
    $ctcs{auto_refresh}           =  ($auto_refresh && int($auto_refresh)) || 0;
    autobalance_bandwidth();
    return with_output_to_string {
      print 'HTTP/1.1 302 Found', $CRLF;
      print $query->redirect(-uri => '/');
    }
  }
  elsif ($target eq '/status-action')
  {
    my $action  = $query->param('action');
    my $id      = CGI::unescape($query->param('torrent-id'));
    my $torrent = get_torrent_by_id($id);

    torrent_pause($torrent)  if $action eq 'Pause';
    torrent_resume($torrent) if $action eq 'Resume';
    torrent_quit($torrent)   if $action eq 'Quit';
    torrent_update($torrent) if $action eq 'Update';

    return with_output_to_string {
      print 'HTTP/1.1 302 Found', $CRLF;
      print $query->redirect(-uri => '/');
    }
  }
  elsif ($target eq '/set-config')
  {
    my $params = $query->Vars;
    my $id = $params->{'torrent-id'};
    my $page = $id ? "/torrent/$id" : '/';
    my $torrent = get_torrent_by_id(CGI::unescape($id));
    my $config = $torrent->{config};

    foreach my $option (keys %$config)
    {
      #########################################################################
      # A mising boolean parameter indicates that the associated checkbox on
      # the form was not set.  Set it explicitly to zero.
      #########################################################################
      if (!exists($params->{$option}) && $config->{$option}->{type} eq 'B')
      {
        $params->{$option} = '0';
      }

      if ($config->{$option}->{value} ne $params->{$option})
      {
        #######################################################################
        # When changing CTCS server, *don't* go back to the info for this page:
        # it belongs to another server
        #######################################################################
        $page = '/' if $option eq 'ctcs_server';
        torrent_set_config($torrent, $option, $params->{$option});
      }
    }

    return with_output_to_string {
      print 'HTTP/1.1 302 Found', $CRLF;
      print $query->redirect(-uri => $page);
    }
  }
  elsif ($target eq '/set-advanced-limits')
  {
    my $params = $query->Vars;
    map {
      my ($operation, $id) = split(/-/, $_, 2);

      if (defined($operation) && defined($id))
      {
        my $torrent = get_torrent_by_id(CGI::unescape($id));
        if ($operation eq 'upload' || $operation eq 'download')
        {
          unless (exists($params->{"automanage-$id"}))
          {
            torrent_set_manual_bandwidth_limit($torrent,
                                               $operation,
                                               $params->{$_} * 1024);
          }
        }
        elsif ($operation eq 'automanage')
        {
          ctcs_log(LOG_INFO,
                   q(Automatically managing bandwidth allocation for '%s'),
                   $torrent->{name});
          delete $torrent->{manual_upload_limit};
          delete $torrent->{manual_download_limit};
        }
      }
    } keys %$params;
    return with_output_to_string {
      print 'HTTP/1.1 302 Found', $CRLF;
      print $query->redirect(-uri => '/advanced-limits');
    }
  }
  elsif ($target =~ '^/api/(.*)$')
  {
    my $params = $query->Vars;
    ctcs_log(LOG_INFO, q(Processing API call '%s'), $1);
    return handle_api_call($1, $params, $client);
  }

  return error_page($target);
}

sub handle_api_call
{
  my ($path, $params, $client) = @_;
  my $handler = $ctcs{api}->{$path} || sub { return unknown_api_call($path, $client); };
  return $handler->($params, $client, $path);
}

sub unknown_api_call
{
  my ($path, $client) = @_;
  ctcs_log(LOG_WARNING, q(Unknown API call: '%s'), $path);
  return json_encode({ 'error' => "Unknown API call '$path'"});
}

###############################################################################
# Wraps a given chunk of text in the body of an HTML page.  If given a CODE
# ref, that ref is invoked with any additional parameters given to it.
# If the last parameter is a HASH ref, it can configure optional elements of
# the page.
#
# Examples:
#
#   html_page('<h2>Boo</h2>');
#   - yields a page with the default stylesheet and JavaScript.
#   html_page('<h2>Boo</h2>', { noscript => 1, nostyle => 1 });
#   - yields a page with NO stylesheet or JavaScript
#   html_page(sub { return '<h2>Boo</h2>' }, { noscript => 1, nostyle => 1 });
#   - as above, but using an anonymous sub to generate the content.
#
# Valid config parameters are currently:
#   - noscript - if true, no JavaScript is added to the page.  Default is false
#   - nostyle  - if true, no stylesheet is added to the page.  Default is false
#   - script   - JavaScript code to use *instead* of the default
#   - style    - CSS to use *instead* of the default.
# noscript and nostyle trump script and style, respectively.
#
###############################################################################

sub html_page
{
  my $content = shift;
  my $config  = ref($_[$#_]) eq 'HASH' ? pop(@_) : {};
  my $script  = $config->{noscript} ? '' : $config->{script} || javascript();
  my $style   = $config->{nostyle} ? '' : $config->{style} || stylesheet();

  $content = $content->(@_) if ref($content) eq 'CODE';

  return join('',
              start_html(-title => 'CTCS 2',
                         -script => $script,
                         -head => style({type => 'text/css'}, $style)),
              $content,
              end_html());
}

sub page_content
{
  my $page = shift;

  return json_status() if ($page eq '/current-status');
  return favicon() if $page eq '/favicon.ico' && defined($favicon);
  return html_page(\&index_page) if $page eq '/';
  return html_page(\&torrent_info_page, $1, { noscript => 1}) if $page =~ /^\/?torrent\/(.+)$/;
  return html_page(\&advanced_limits_page, { noscript => 1}) if $page eq '/advanced-limits';
  return html_page(\&debug_page, { nostyle => 1, noscript => 1 }) if $page eq '/debug';

  return undef;
}

sub json_status
{
  my ($dl, $ul) = total_used_bandwidth();
  my @statuses  = status_of_multiple_torrents(all_torrents());
  my $data      = { 'download' => human_readable($dl) . '/s',
                    'upload'   => human_readable($ul) . '/s',
                    'torrents' => \@statuses };
  return json_encode($data);
}

sub status_of_multiple_torrents
{
  return my @statuses = map { status_of_single_torrent($_) } @_;
}

sub json_status_of_multiple_torrents
{
  my @torrents = status_of_multiple_torrents(@_);
  return json_encode(\@torrents);
}

sub status_of_single_torrent
{
  torrent_summary(shift, SUMMARY_FULL);
}

sub json_status_of_single_torrent
{
  return json_encode(status_of_single_torrent(shift));
}

###############################################################################
# A convenience function to encode an arbitrary structure of Perl strings,
# array refs and hashrefs as a JSON formatted string.
###############################################################################

sub json_encode
{
  my ($content, $handle) = ('');
  open($handle, '>', \$content) || die $!;
  eval { json_encode_to_stream(shift, $handle) };
  close($handle);
  die $@ if $@;
  return $content;
}

sub json_encode_to_stream
{
  my ($entity, $stream) = @_;
  my $type   = ref($entity);

  if ( $type eq 'ARRAY' )
  {
    print $stream '[';
    json_encode_to_stream($_, $stream) && print $stream ',' for @$entity;
    seek($stream, -1, SEEK_CUR) unless scalar @$entity == 0;
    print $stream ']';
  }
  elsif ( $type eq 'HASH' )
  {
    print $stream '{';
    while ( my ($key, $value) = each %$entity)
    {
      json_encode_to_stream($key, $stream);
      print $stream ':';
      json_encode_to_stream($value, $stream);
      print $stream ',';
    }
    seek($stream, -1, SEEK_CUR);
    print $stream '}';
  }
  else
  {
    if ( !defined($entity) )
    {
      print $stream 'null';
    }
    elsif ( Scalar::Util::looks_like_number($entity) )
    {
      print $stream $entity;
    }
    else
    {
      $entity =~ s/"/\\"/g;
      printf $stream '"%s"', $entity;
    }
  }

  return $stream;
}

sub pretty_print_json_string_ref
{
  my $json_string_ref  = shift;
  my $spaces           = shift || 4;
  my $stream           = undef;
  my $in_string        = 0;
  my $escape_next_char = 0;
  my @offsets          = (0);

  open ($stream, '<', $json_string_ref ) || die $!;

  while(defined(my $char = getc($stream)))
  {

    if ( $in_string && $char eq '\\' )
    {
      $escape_next_char = 1;
      next;
    }

    if ( $escape_next_char )
    {
      print '\\', $char;
      $escape_next_char = 0;
      next;
    }

    if ( $char eq '"' )
    {
      $in_string = !$in_string;
      print $char;
      next;
    }

    if ( !$in_string )
    {
      if ( $char eq '{' || $char eq '[' )
      {
        print $char, "\n";
        push(@offsets, $offsets[$#offsets] + $spaces);
        print ' ' x $offsets[$#offsets];
        next;
      }

      if ( $char eq '}' || $char eq ']' )
      {
        print "\n";
        pop(@offsets);
        print ' ' x $offsets[$#offsets];
        print $char;
        next;
      }

      if ( $char eq "\n" )
      {
        print $char;
        print ' ' x $offsets[$#offsets];
        next;
      }

      if ( $char eq ',' )
      {
        print $char, "\n";
        print ' ' x $offsets[$#offsets];
        next;
      }

      if ( $char eq ':' )
      {
        print ' : ';
        next;
      }
    }

    print $char;
  }

  print "\n";
}

###############################################################################
# Given a number of seconds, returns a string of format: H:MM:SS
###############################################################################

sub human_readable_time
{
  my $seconds = shift;
  my $minutes = ($seconds/60) % 60;
  my $hours   = ($seconds/3600);
  $seconds    =  $seconds % 60;

  return sprintf('%d:%02d:%02d', $hours, $minutes, $seconds);
}

###############################################################################
# Calculate the time remaining for a given download rate and chunk data.
###############################################################################

sub calculate_time_remaining
{
  my $downloaded_chunks = shift;
  my $total_chunks      = shift;
  my $chunk_size        = shift;
  my $download_rate     = shift;

  if ( $downloaded_chunks && $total_chunks && $chunk_size && $download_rate &&
       $downloaded_chunks != $total_chunks &&
       $download_rate > 0 ) {
    return human_readable_time((($total_chunks - $downloaded_chunks) * $chunk_size) / $download_rate);
  }
  else
  {
    return '-';
  }
}

###############################################################################
# The front page
###############################################################################

sub index_page
{
  return with_output_to_string {
    print h2({-id => 'title'},
             'CTorrent Control Server' .
             span({style=>'font-size: 250%; font-style: italic; position: relative; z-index: -1; top: 0.2em; right: 0.75em; color: #bfb;'},
                  '2'));
    my ($download_bandwidth, $upload_bandwidth) = total_used_bandwidth();
    my $current_download_field = human_readable($download_bandwidth);
    my $current_upload_field = human_readable($upload_bandwidth);
    my $download_field = textfield({name      => 'dlimit',
                                    value     => ($ctcs{download_limit} / 1024),
                                    maxlength => 6,
                                    tabindex  => 1,
                                    size      => 6});
    my $upload_field = textfield({name      => 'ulimit',
                                  value     => ($ctcs{upload_limit} / 1024),
                                  maxlength => 6,
                                  tabindex  => 2,
                                  size      => 6});
    my $submit_button = submit({name     => 'submit-bandwidth-changes',
                                value    => 'Apply Changes',
                                tabindex => 3});

    printf '<form method="post" action="/" enctype="%s">', FORM_ENCODING;
    print div({id => 'global-bandwidth-limits'},
              div({style => 'position: absolute; top: 0px; left: 0px; color: transparent'},
                  $$),
              table(
                    Tr(th('Current Download Bandwidth:'),
                       td({id => 'download-bandwidth'},
                          $current_download_field . '/s')),
                    Tr(th('Current Upload Bandwidth:'),
                       td({id => 'upload-bandwidth'},
                          $current_upload_field . '/s')),
                    Tr(th('Global Download Limit:'),
                       td($download_field, ' KB/s')),
                    Tr(th('Global Upload Limit:'),
                       td($upload_field, ' KB/s')),
                    Tr(th('Auto-Refresh:'),
                       td(checkbox(-name     => 'auto-refresh',
                                   -label    => '',
                                   -value    => '1',
                                   -id       => 'auto-refresh',
                                   -tabindex => 4,
                                   -checked  => $ctcs{auto_refresh}))),
                    Tr(td(a({href  => '/advanced-limits',
                             title => 'Fine-grained control over bandwidth limits'},
                            'Advanced Limits')),
                       td({align => 'right'},
                          $submit_button))));
    print end_form();

    print CGI::start_table({id => 'torrents'});
    print Tr(th('Name'), th('% Complete'), th('Time Remaining'), th('Download Rate'), th('Upload Rate'),
             th('Seeds'), th('Leeches'), th('Downloaded'), th('Uploaded'),
             th('Size'), th('Ratio'), th('Action'));

    my @torrent_info = sort {
      ($b->{percent_complete} || 0) <=> ($a->{percent_complete} || 0)
    } map { torrent_handled_by($_) } torrent_clients();

    for (my $count = 0; $count < @torrent_info; $count++)
    {
      my $torrent          = $torrent_info[$count];
      my $torrent_id       = CGI::escape($torrent->{ctcs_id});
      my $torrent_link     = a({href=> '/torrent/' . CGI::escape($torrent->{ctcs_id})}, $torrent->{name});
      my $upload_rate      = human_readable($torrent->{upload_rate});
      my $download_rate    = human_readable($torrent->{download_rate});
      my $total_seeders    = $torrent->{total_seeders};
      my $active_seeders   = $torrent->{active_seeders};
      my $total_leechers   = $torrent->{total_leechers};
      my $active_leechers  = $torrent->{active_leechers};
      my $downloaded       = human_readable($torrent->{downloaded}, '0.2f');
      my $uploaded         = human_readable($torrent->{uploaded}, '0.2f');
      my $size             = human_readable($torrent->{size}, 'd', '0.2f');
      my $percent_complete = sprintf('%d%%', $torrent->{percent_complete});

      my $time_to_finish   = calculate_time_remaining($torrent->{downloaded_chunks},
                                                      $torrent->{total_chunks},
                                                      $torrent->{piece_size},
                                                      smoothed_dl_rate($torrent));
      my $raw_ratio        = ($torrent->{uploaded} == 0) ? 0 :
      ($torrent->{downloaded} == 0) ? 'Inf.' :
      $torrent->{uploaded} / $torrent->{downloaded};
      my $ratio            = formatted_ratio_for($torrent);
      my $row_class        = ($count % 2 == 0) ? 'torrent-even' : 'torrent-odd';
      $row_class .= ' complete' if $torrent->{percent_complete} == 100;
      my $red              = ($ratio eq 'Inf.') ? 0 : int((1 - $ratio) * 255);
      my $green            = ($ratio eq 'Inf.') ? 255 : int($ratio * 128);

      $red   = 0 if $red < 0;
      $green = 255 if $ratio eq 'Inf.' || $ratio > 255;

      my $row_colour       = sprintf('#%06x', ($red << 16 | $green << 8 | 0));
      my $pause_unpause = $torrent->{config}->{pause}->{value} == 1 ? 'Resume' : 'Pause';

      $torrent->{config}->{pause}->{value} == 1 && ($row_class .= ' paused');
      print Tr({class => $row_class,
                id    => $torrent_id},
               td({class => 'title'}, $torrent_link),
               td({id => "percent_complete-$torrent_id"}, $percent_complete),
               td({id => "time_remaining-$torrent_id"}, $time_to_finish),
               td({id => "download_rate-$torrent_id"}, $download_rate . '/s'),
               td({id => "upload_rate-$torrent_id"}, $upload_rate . '/s'),
               td({id => "seeders-$torrent_id"}, $active_seeders, '/', $total_seeders),
               td({id => "leechers-$torrent_id"}, $active_leechers, '/', $total_leechers),
               td({id => "downloaded-$torrent_id"}, $downloaded),
               td({id => "uploaded-$torrent_id"}, $uploaded),
               td({id => "size-$torrent_id"}, $size),
               td({style => "color: $row_colour", id => "ratio-$torrent_id"}, $ratio),
               td(sprintf('<form name="%s" method="post" action="/status-action" enctype="%s">',
                          $torrent_id,
                          FORM_ENCODING),
                  Select({name         => 'action'},
                         option({value => $pause_unpause,
                                 id    => "pause_unpause-$torrent_id"},
                                $pause_unpause),
                         option({value => 'Update'}, 'Update'),
                         option({value => 'Quit'}, 'Quit')),
                  submit(-name         => 'submit', -value => 'Ok'),
                  hidden(-name         => 'torrent-id', -value => $torrent_id),
                  end_form()));
    }
    print CGI::end_table();
    print q(<script type="text/javascript">setTimeout('update_with_current_status()', 5000);</script>);
  };
}

sub formatted_ratio_for
{
  my $torrent = shift;
  my $raw_ratio        = ($torrent->{uploaded} == 0) ? 0 :
  ($torrent->{downloaded} == 0) ? 'Inf.' :
  $torrent->{uploaded} / $torrent->{downloaded};
  return ($raw_ratio eq 'Inf.') ? 'Inf.' : sprintf('%.02f', $raw_ratio);
}

###############################################################################
# The stats/info page for a given torrent
###############################################################################

sub torrent_info_page
{
  my $encoded_id     = shift;
  my $decoded_id     = CGI::unescape($encoded_id);
  my $torrent_info   = get_torrent_by_id($decoded_id);

  return undef if !defined($torrent_info);

  my $torrent_name   = $torrent_info->{name};
  my @peers          = sort { $b->{pieces} <=> $a->{pieces} } @{$torrent_info->{peers}};
  my %config         = %{$torrent_info->{config}};
  my @files          = @{$torrent_info->{files}};
  my @config_options = sort keys %config;
  return with_output_to_string {
    print h2({id => 'title'}, $torrent_name);
    print a({style=>'float: right;', href=>'/'}, 'Home');
    print h3('Peers');
    print ctcs_peers_table($torrent_info);
    print h3('Config');
    print ctcs_config_table($torrent_info);
    print h3('Files');
    print ctcs_file_table($torrent_info);
    print a({style=>'float: right;', href=>'/'}, 'Home');
  };
}

sub advanced_limits_page
{
  return with_output_to_string {
    my @clients = torrent_clients();
    print h2({id => 'title'}, 'Advanced Bandwidth Limits');
    print h3({style => 'text-align: center' },
             sprintf('Global Upload Limit: %s/s; Global Download Limit: %s/s',
                     human_readable($ctcs{upload_limit}),
                     human_readable($ctcs{download_limit})));
    printf '<form action="/set-advanced-limits" method="post" enctype="%s">', FORM_ENCODING;
    print CGI::start_table({id => 'torrents'});
    print Tr(th('Torrent'), th('Upload Limit (KB/s)'), th('Download Limit (KB/s)'), th('Auto-Manage'));

    for (my $count = 0; $count < scalar @clients; $count++)
    {
      my $client = $clients[$count];
      my $torrent = torrent_handled_by($client);
      my $upload_limit = int(($torrent->{manual_upload_limit} || $torrent->{upload_limit} || 0) / 1024);
      my $download_limit = int(($torrent->{manual_download_limit} || $torrent->{download_limit} || 0) / 1024);
      my $id = CGI::escape($torrent->{ctcs_id});
      my $upload_limit_widget = textfield(-name => "upload-$id",
                                          -size => 6,
                                          -value => $upload_limit);
      my $download_limit_widget = textfield(-name => "download-$id",
                                            -size => 6,
                                            -value => $download_limit);
      my $auto_manage_widget = checkbox(-name => "automanage-$id",
                                        -label => '',
                                        -value => 1,
                                        -title => 'Tick to have ctorrent automatically manage bandwidth for this torrent',
                                        -checked =>
                                        !exists($torrent->{manual_download_limit}) &&
                                        !exists($torrent->{manual_upload_limit})
                                       );
      print Tr({class => ($count % 2) == 0 ? 'torrent-even' : 'torrent-odd'},
               td({class => 'title'}, $torrent->{name}),
               td($upload_limit_widget),
               td($download_limit_widget),
               td($auto_manage_widget)
              );
    }
    print Tr(td(a({href => '/', title => 'Go to front page'}, 'Home')),
             td({colspan => '2', align => 'right'}, submit(-value => 'Apply Changes')));
    print CGI::end_table();
    print end_form();
  }
}

sub ctcs_file_table
{
  my $torrent_info = shift;
  my @files        = @{$torrent_info->{files}};

  return with_output_to_string {
    print CGI::start_table({id => 'files'});
    print Tr(th('File'), th('Size'), th('% Complete'));

    for (my $count = 1; $count < scalar @files; $count++)
    {
      my $file = $files[$count];
      print Tr({class => ($count % 2 == 1) ? 'file-even' : 'file-odd'},
               td({class => 'title'}, $count, ': ', $file->{name}),
               td({align => 'right'}, human_readable($file->{size}, 'd', '.02f')),
               td({align => 'right'}, int($file->{percent_done}), '%'));
    }
    print CGI::end_table();
  }
}

sub ctcs_config_table
{
  my $torrent_info   = shift;
  my %config         = %{$torrent_info->{config}};
  my @config_options = sort keys %config;
  return with_output_to_string {
    printf '<form method="post" action="/set-config" enctype="%s">', FORM_ENCODING;
    print CGI::start_table({id => 'config'});
    print Tr(th('Option'), th({colspan => 2}, 'Value'));

    for (my $count = 0; $count < scalar @config_options; $count++)
    {
      print Tr({class => ($count % 2 == 0) ? 'peer-even' : 'peer-odd'},
               td($config{$config_options[$count]}->{short_desc}),
               td(ctcs_config_table_widget($config_options[$count],
                                           $config{$config_options[$count]})),
               td($config{$config_options[$count]}->{long_desc}));
    }
    print Tr(td(), td(submit(-value => 'Apply Changes')), td());
    print CGI::end_table();
    print hidden(-name => 'torrent-id', -value => CGI::escape($torrent_info->{ctcs_id}));
    print end_form();
  }
}

sub ctcs_config_table_widget
{
  my ($field, $option) = @_;
  if ($option->{type} eq 'B')
  {
    return checkbox(-name    => $field,
                    -value   => '1',
                    -label   => '',
                    -checked => $option->{value} eq '1');
  }
  else
  {
    return textfield(-name  => $field,
                     -size  => 12,
                     -value => $option->{value});
  }
}

sub ctcs_peers_table
{
  my $torrent_info = shift;
  my @peers        = sort { $b->{pieces} <=> $a->{pieces} } @{$torrent_info->{peers}};

  return with_output_to_string {
    print CGI::start_table({id => 'peers', width => '100%'});
    print Tr(th(), th('Address'), th('Chunks (of ', $torrent_info->{total_chunks}, ')'),
             th('Uploaded (from you)'), th('Upload Rate'),
             th('Downloaded (to you)'), th('Download Rate'));
    for (my $count = 0; $count < scalar @peers; $count++)
    {
      my $peer      = $peers[$count];
      print Tr({class => ($count % 2 == 0) ? 'peer-even' : 'peer-odd'},
               td({class => ($peer->{pieces} == $torrent_info->{total_chunks}) ? 'seed' : 'leech'}),
               td($peer->{address}),
               td($peer->{pieces},
                  sprintf('(%d%%)', int(($peer->{pieces} / $torrent_info->{total_chunks}) * 100))),
               td(human_readable($peer->{uploaded})),
               td(human_readable($peer->{upload_rate})),
               td(human_readable($peer->{downloaded})),
               td(human_readable($peer->{download_rate})));
    }
    print CGI::end_table();
  };
}

###############################################################################
# A handy page dumping the internals of what's going on
###############################################################################

sub debug_page
{
  return with_output_to_string {
    print h1('Debug');
    print CGI::start_pre();
    print handle_dump();
    print CGI::end_pre();
  };
}

###############################################################################
# The page you get when no other page matched up to your request
###############################################################################

sub error_page
{
  my $page = shift;
  return with_output_to_string {
    print h1('Whoops!');
    print p("The page you're looking for, $page, doesn't exist!");
    print a({href=>'/'}, 'Go Home');
  };
}

###############################################################################
# Dumps out a list of currently registered sockets.  This is useful for
# debugging
###############################################################################

sub handle_dump
{
  my $json;
  return with_output_to_string {
    print "CTCS\n\n";
    $json = json_encode(\%ctcs);
    pretty_print_json_string_ref(\$json);
    print "\nREADERS\n\n";
    map { printf "%s: %s:%d (%s)\n",
          $_,
          $_ == $server ? 'SERVER' : address_of($_),
          $_ == $server ? $ctcs{port} : $_->peerport(),
          $_ == $server ? 'SERVER' : exists($clients{$_}->{torrent}) ? 'TORRENT: ' . $clients{$_}->{torrent}->{name} : 'WEB'
        } $readers->handles;
    print "\nWRITERS\n\n";
    map { printf "%s: %s:%d (%s)\n",
          $_,
          $_ == $server ? 'SERVER' : address_of($_),
          $_ == $server ? $ctcs{port} : $_->peerport(),
          $_ == $server ? 'SERVER' : exists($clients{$_}->{torrent}) ? 'TORRENT: ' . $clients{$_}->{torrent}->{name} : 'WEB'
        } $writers->handles;
    print "\nCLIENTS\n\n";
    $json = json_encode(\%clients);
    pretty_print_json_string_ref(\$json);
  };
}

###############################################################################
# Note download/upload figures for a particular client.
###############################################################################

sub record_bandwidth
{
  my ($client, $dlrate, $ulrate) = @_;
  my $torrent = torrent_handled_by($client);
  $torrent->{upload_rate}   = $ulrate;
  $torrent->{download_rate} = $dlrate;
  my $write_index           = \($torrent->{rec_bw_index} ||= 0);

  $torrent->{download_rate_history}->[$$write_index++] = $dlrate;
  $$write_index = 0 if $$write_index >= 100;

  my $total = exists($torrent->{total_chunks}) ?
    $torrent->{total_chunks} :
    0;

  my $downloaded = exists($torrent->{downloaded_chunks}) ?
    $torrent->{downloaded_chunks} :
    0;

  $torrent->{percent_complete} = $total == 0 ?
    0 :
    int(($downloaded / $total) * 100);
}

###############################################################################
# Handles internal registration of the given torrent.  Until explicitly
# de-registered, this torrent will remain on this server's list for the
# server lifetime.
###############################################################################

sub handle_register_torrent
{
  my ($socket, $torrent_id, $start_time, $current_time, $torrent_name) = @_;

  my $info = {};
  $info->{name}                  = $torrent_name;
  $info->{ctorrent_id}           = $torrent_id;
  $info->{ctcs_id}               = 'ctcs-torrent-' . ++$current_id;
  $info->{config}                = { pause => {value => 0}};
  $info->{percent_complete}      = 0;
  $info->{files}                 = [];
  $info->{peers}                 = [];
  $info->{active_seeders}        = 0;
  $info->{total_seeders}         = 0;
  $info->{active_leechers}       = 0;
  $info->{total_leechers}        = 0;
  $info->{total_connections}     = 0;
  $info->{downloaded_chunks}     = 0;
  $info->{total_chunks}          = 0;
  $info->{available_chunks}      = 0;
  $info->{download_rate}         = 0;
  $info->{download_rate_history} = [];
  $info->{upload_rate}           = 0;
  $info->{downloaded}            = 0;
  $info->{uploaded}              = 0;
  $info->{download_limit}        = 0;
  $info->{upload_limit}          = 0;
  $info->{cache_used}            = 0;
  $info->{last_detail_update}    = 0;
  $info->{size}                  = 0;

  $clients{$socket}->{torrent} = $info;

}

sub smoothed_dl_rate
{
  my $torrent = $_[0];
  my $smoothed_dl_rate = 0;
  $smoothed_dl_rate += $_ for @{$torrent->{download_rate_history}};
  $smoothed_dl_rate = $smoothed_dl_rate/$#{$torrent->{download_rate_history}} if $smoothed_dl_rate > 0;
  return $smoothed_dl_rate;
}

###############################################################################
# Defines a function that reads lines from an I/O handle given to it.  Can,
# if given a second 'limit' parameter, instead be used to read a specific
# number of bytes.
#
# * If the line is successfully read, this method returns the completed line.
# * If a full line cannot be read (but *something* is) this method returns
#   undef, and $! is EAGAIN.  The partially read string is stored for
#   a later read.
# * If nothing can be read, and the underlying read hasn't set $!, this
#   method returns undef: check $! to determine what has happened.
###############################################################################

sub line_reader_function
{
  my ($buffer, $buffer_length) = ('', 0);

  return sub {

    my $client          = shift; # Mandatory
    my $bytes_requested = shift; # Optional

    ###########################################################################
    # Figure out how much has to be retrieved from sysread, rather than using
    # the internal buffer.  In the case of reading lines, this could well be
    # zero, if the buffered data already has a complete line in it.
    ###########################################################################

    my $external_read_size =
    (defined($bytes_requested) && $bytes_requested >= $buffer_length) ?
    $bytes_requested - $buffer_length :
    ($buffer               =~ tr/\n/\n/) ? 0 :
    1024;

    ###########################################################################
    # Read from the exteral source, if required
    ###########################################################################

    if ($external_read_size > 0)
    {
      my $result = sysread($client, $buffer, $external_read_size, $buffer_length);
      return undef if !defined($result) || $result == 0;
      $buffer_length += $result;
    }

    ###########################################################################
    # $bytes_requested, if defined, indicates the minimum that the caller
    # wanted: don't give back anything if the entire request can't be
    # satisfied.
    # Without $bytes_requested, the absence of a newline in the buffer means
    # that a complete line can't be returned: return undef instead.
    ###########################################################################

    return undef if defined($bytes_requested) && $bytes_requested < $buffer_length;
    return undef unless defined($bytes_requested) || $buffer =~ /\n/g;

    ###########################################################################
    # Ok, by now, $buffer has enough data in it, so extract the line/required
    # number of bytes and adjust the internal buffer appropriately.
    ###########################################################################

    my $snip_point   = $bytes_requested || pos($buffer);
    my $line         = substr($buffer, 0, $snip_point);
    $buffer          = $snip_point < $buffer_length ? substr($buffer, $snip_point) : '';
    $buffer_length  -= length($line);

    ###########################################################################
    # Unless extracting a specific number of bytes, trim off any blank spaces
    # at the end of the line
    ###########################################################################

    unless (defined($bytes_requested))
    {
      local $/ = $CRLF;
      chomp($line);
    }

    return $line;
  };
}

###############################################################################
# A simple logger.
###############################################################################

sub ctcs_log
{
  return if $_[0]->[0] < $ctcs{log_level};
  my ($level, $format) = (shift, shift);
  my $log = $ctcs{log_file_handle} || \*STDOUT;
  if ($ctcs{log_timestamps})
  {
    print $log strftime("%H:%M:%S, %a, %b %d %Y", localtime()), ': ';
  }
  print $log $level->[1], ' ';
  printf $log $format, @_;
  print $log "\n";
}

###############################################################################
# Given a socket, returns a hash reference with keys representing information
# about a torrent file (the most important usually being 'name')
###############################################################################

sub torrent_handled_by
{
  return $clients{$_[0]}->{torrent};
}

###############################################################################
# Return all torrent instances currently registered with this server
###############################################################################

sub all_torrents
{
  map { $clients{$_}->{torrent} } grep { exists($clients{$_}->{torrent}) } keys %clients;
}

###############################################################################
# Returns a list of sockets that are supplying torrent data (as opposed to
# connections from the Web interface
###############################################################################

sub torrent_clients
{
  my @torrent_clients = ();
  foreach my $client (keys %clients)
  {
    push(@torrent_clients, $clients{$client}->{socket}) if exists($clients{$client}->{torrent});
  }
  return @torrent_clients;
}

###############################################################################
# Figures out what the average bandwidth for each register torrent should be
# given the global download and upload limits.
###############################################################################

sub autobalance_bandwidth
{
  my @torrent_clients  = torrent_clients();
  my $client_count     = scalar(@torrent_clients) || 1;
  my $uploader_count   = 0;
  my $downloader_count = 0;

  foreach my $client (@torrent_clients)
  {
    my $torrent  = torrent_handled_by($client);
    my $complete = $torrent->{percent_complete} eq '100';
    my $paused   = $torrent->{config}->{pause}->{value} eq '1';
    $uploader_count++ unless $paused;
    $downloader_count++ unless ($paused || $complete);
  }

  $uploader_count   ||= 1;
  $downloader_count ||= 1;

  foreach my $client (@torrent_clients)
  {
    my $torrent  = torrent_handled_by($client);
    my $paused   = $torrent->{config}->{pause}->{value} == 1;
    my $complete = $torrent->{percent_complete} == 100;

    my $upload_limit   = $paused ? 0 :
    (exists($torrent->{manual_upload_limit})) ?
    $torrent->{manual_upload_limit}  :
    int($ctcs{upload_limit} / $uploader_count);

    my $download_limit = ($paused || $complete) ? 0 :
    (exists($torrent->{manual_download_limit})) ?
    $torrent->{manual_download_limit} :
    int($ctcs{download_limit} / $downloader_count);

    if ($upload_limit != $torrent->{upload_limit})
    {
      torrent_set_bandwidth_limit($torrent, 'upload', $upload_limit);
    }
    if ($download_limit != $torrent->{download_limit})
    {
      torrent_set_bandwidth_limit($torrent, 'download', $download_limit);
    }
  }
}

###############################################################################
# Sends the given string as a message to the given client.  This doesn't
# happen immediately: the message is queued for sending with the next
# write loop.
###############################################################################

sub send_message
{
  my ($message, $client) = @_;
  send_message_function(writer_function(sub { $message }), $client);
}

###############################################################################
# Tags an HTTP header onto the given message.  Specific HTTP headers can be
# set using the same mechanism as with send_http_message
###############################################################################

sub prepare_http_message
{
  my ($message, %headers) = @_;
  my $handle = IO::Handle->new();
  my $http_message = '';
  open($handle, '>', \$handle) || die $!;

  $headers{'Content-Type'} ||= 'text/plain';

  print $http_message 'HTTP/1.1 200 OK', $CRLF;
  map { print $http_message $_, ': ', $headers{$_}, $CRLF } keys %headers;
  print $http_message 'Content-Length: ', length($message), $CRLF, $CRLF;
  print $http_message $message;

  return $http_message;
}

###############################################################################
# Adds the given writer function to the message queue of the given client.
# As with send_message, the send doesn't happen immediately.
###############################################################################

sub send_message_function
{
  my ($function, $client) = @_;
  push (@{$clients{$client}->{messages}}, $function);
  $writers->add($client) unless $writers->exists($client);
}

###############################################################################
# For a given id, find the torrent subhash in %clients that contains the
# information about that torrent.  Return undef if no such torrent is found
###############################################################################

sub get_torrent_by_id
{
  my $id = shift;

  foreach my $client (keys %clients)
  {
    if (exists($clients{$client}->{torrent}) &&
        $clients{$client}->{torrent}->{ctcs_id} eq $id) {
      return $clients{$client}->{torrent};
    }
  }
  return undef;
}

sub get_client_by_id
{
  my $id = shift;

  foreach my $client (keys %clients)
  {
    if (exists($clients{$client}->{torrent}) &&
        $clients{$client}->{torrent}->{ctcs_id} eq $id) {
      return $clients{$client}->{socket};
    }
  }
  return undef;
}

###############################################################################
# Returns a two element list containing the total download and upload bandwidth
# figures for torrents registered with this server.
###############################################################################

sub total_used_bandwidth
{
  my $total_upload = 0;
  my $total_download = 0;
  foreach my $client (torrent_clients())
  {
    $total_upload   += ($clients{$client}->{torrent}->{upload_rate} || 0);
    $total_download += ($clients{$client}->{torrent}->{download_rate} || 0);
  }
  return ($total_download, $total_upload);
}

###############################################################################
# Which protocol version?
# (kinda redundant as I don't pay attention to it anywhere yet.
###############################################################################

sub ctcs_protocol
{
  return $ctcs{protocol};
}

###############################################################################
# The command that should be sent to get more detail
###############################################################################

sub ctcs_request_detail_command
{
  return "SENDDETAIL\r\n";
}

sub ctcs_request_status_command
{
  return "SENDSTATUS\r\n";
}

sub ctcs_request_config_command
{
  return "SENDCONF\r\n";
}

sub ctcs_request_peers_command
{
  return "SENDPEERS\r\n";
}

###############################################################################
# Given the torrent info subhash and the detail string returned by
# an incoming CTFILE, populates the torrent hash with the details
# After this is complete, $torrent_info{files} is a list reference, indexed
# by file number (in the torrent), and where each element is a hash reference
# containing the 'size' and 'name' keys.
###############################################################################

sub torrent_populate_file_info
{
  my ($torrent_info, $detail_string) = @_;
  my ($fnum, $fpri, $curpri, $fnp, $fnh, $fna, $fsize, $fname) =
  split(/\s+/, $detail_string, 8);
  $torrent_info->{files} ||= [];
  $torrent_info->{files}->[$fnum] ||= {};
  $torrent_info->{files}->[$fnum]->{size} = $fsize;
  $torrent_info->{files}->[$fnum]->{name} = $fname;
  $torrent_info->{files}->[$fnum]->{percent_done} = $fnp ? 100 * $fnh / $fnp : 0;
}

sub torrent_update_detail
{
  torrent_update_only_after_minimum_time(shift,
                                         'last_detail_update',
                                         5,
                                         \&torrent_request_detail_from);
}

sub torrent_update_status
{
  torrent_update_only_after_minimum_time(shift,
                                         'last_status_update',
                                         10,
                                         \&torrent_request_status_from);
}

sub torrent_update_config
{
  torrent_update_only_after_minimum_time(shift,
                                         'last_config_update',
                                         10,
                                         \&torrent_request_config_from);
}

sub torrent_update_peers
{
  my ($client) = @_;
  return if exists(torrent_handled_by($client)->{incoming_peers});
  torrent_update_only_after_minimum_time(shift,
                                         'last_peers_update',
                                         30,
                                         \&torrent_request_peers_from);
}

sub ctcs_update_bandwidth_allocation
{
  ctcs_update_only_after_minimum_time('last_bandwidth_update',
                                      10,
                                      \&autobalance_bandwidth);
}

sub torrent_update_only_after_minimum_time
{
  my ($client, $field, $interval, $request_function) = @_;
  my $torrent_info = torrent_handled_by($client);
  my $time = time();
  if (!exists($torrent_info->{$field}) ||
      ($time - $torrent_info->{$field} > $interval)) {
    $request_function->($client);
    $torrent_info->{$field} = $time;
  }
}

sub ctcs_update_only_after_minimum_time
{
  my ($field, $interval, $function, @args) = @_;
  my $time = time();
  if (!exists($ctcs{$field}) || ($time - $ctcs{$field} > $interval))
  {
    $function->(@args);
    $ctcs{$field} = $time;
  }
}

sub torrent_set_status
{
  my ($torrent_info, $status_line) = @_;

  # Apologies for the horrendous pattern match.
  $status_line =~ m!^
                    (\d+):(\d+)/       # Active seeds, and total seeders
                    (\d+):(\d+)/       # Active leechers, and total leechers
                    (\d+)              # Total connections
                    \s+
                    (\d+)/(\d+)/(\d+)  # Chunks downloaded, total, and available
                    \s+
                    (\d+),(\d+)        # Download/upload rates
                    \s+
                    (\d+),(\d+)        # Total downloaded/uploaded
                    \s+
                    (\d+),(\d+)        # Download/upload limits
                    \s+
                    (\d+)              # Cache used
                   !x;

  $torrent_info->{active_seeders}     = $1;
  $torrent_info->{total_seeders}      = $2;
  $torrent_info->{active_leechers}    = $3;
  $torrent_info->{total_leechers}     = $4;
  $torrent_info->{total_connections}  = $5;
  $torrent_info->{downloaded_chunks}  = $6;
  $torrent_info->{total_chunks}       = $7;
  $torrent_info->{available_chunks}   = $8;
  $torrent_info->{download_rate}      = $9;
  $torrent_info->{upload_rate}        = $10;
  $torrent_info->{downloaded}         = $11;
  $torrent_info->{uploaded}           = $12;
  $torrent_info->{download_limit}     = $13;
  $torrent_info->{upload_limit}       = $14;
  $torrent_info->{cache_used}         = $15;
  $torrent_info->{last_detail_update} = time();
}

################################################################################
# Asynchronously sends a SENDDETAIL request to the given client.
###############################################################################

sub torrent_request_status_from
{
  send_message(ctcs_request_status_command(), shift);
}

sub torrent_request_detail_from
{
  send_message(ctcs_request_detail_command(), shift);
}

sub torrent_request_peers_from
{
  send_message(ctcs_request_peers_command(), shift);
}

sub torrent_request_config_from
{
  send_message(ctcs_request_config_command(), shift);
}

sub torrent_store_config
{
  my ($torrent, $config_line) = @_;
  if ($config_line =~ /(\S+)      # element name
                       \s+
                       (\S+)      # element type
                       \s+
                       (\S+)      # element range
                       \s+
                       (\d+):     # element length
                      /gx) {
    my ($short_description, $long_description);
    my ($element, $type, $range, $value_length) = ($1, $2, $3, $4);
    my $value = substr($config_line, pos($config_line), $value_length);
    my $length = $1 if $config_line =~ /\s*(\d+):/g;
    if ($length)
    {
      $short_description = substr($config_line, pos($config_line), $length);
    }
    $length = $1 if $config_line =~ /(\d+):/g;
    if ($length)
    {
      $long_description = substr($config_line, pos($config_line), $length);
    }

    my $config = ($torrent->{config}->{$element} ||= {});

    $config->{short_desc}  = $short_description || '';
    $config->{long_desc}   = $long_description  || '';
    $config->{type}        = $type;
    $config->{range}       = $range;
    $config->{value}       = $value;
    $config->{validator} ||= attach_config_validator($config, $element, $torrent->{name});
  }
}

sub string_config_validator
{
  my ($element, $value, $element_name, $torrent_name) = @_;
  ctcs_log( LOG_DEBUG, q(Validating string value '%s' for option '%s' of '%s'),
            $value, $element_name, $torrent_name );

  return
  defined($value)              &&
  defined($element->{type})    &&
  $element->{type} eq 'S'      &&
  defined($element->{range})   &&
  $element->{range} =~ /^\d+$/ &&
  length($value) <= $element->{range};
}

sub integer_config_validator
{
  my ($element, $value, $element_name, $torrent_name) = @_;
  ctcs_log( LOG_DEBUG, q(Validating integer value '%s' for option '%s' of '%s'),
            $value, $element_name, $torrent_name );

  return 0 unless defined($value) && $value =~ /^\d+$/;
  return 0 unless defined($element->{type}) && $element->{type} eq 'I';

  return ( $element->{range} =~ /^(\d+)-(\d+)$/ ) ?
  $value >= $1 && $value <= $2 :
  1;
}

sub float_config_validator
{
  my ($element, $value, $element_name, $torrent_name) = @_;
  ctcs_log( LOG_DEBUG, q(Validating float value '%s' for option '%s' of '%s'),
            $value, $element_name, $torrent_name );

  return 0 unless defined($value) && $value =~ /^\d+(?:\.\d+)?$/;
  return 0 unless defined($element->{type}) && $element->{type} eq 'F';

  return 1;
}

sub boolean_config_validator
{
  my ($element, $value, $element_name, $torrent_name) = @_;
  ctcs_log( LOG_DEBUG, q(Validating boolean value '%s' for option '%s' of '%s'),
            $value, $element_name, $torrent_name );

  return $value == 1 || $value == 0;
}

sub null_warning_validator
{
  my ($element, $value, $element_name, $torrent_name) = @_;
  ctcs_log( LOG_WARNING, q(No validator for config option '%s' of '%s'), $element_name, $torrent_name );
}

sub attach_config_validator
{
  my ($element, $element_name, $torrent_name) = @_;
  my $validator = ($element->{type} eq 'S') ? \&string_config_validator :
  ($element->{type} eq 'I') ? \&integer_config_validator :
  ($element->{type} eq 'F') ? \&float_config_validator :
  ($element->{type} eq 'B') ? \&boolean_config_validator :
  \&null_warning_validator;

  return sub {
    return $validator->($element, shift, $element_name, $torrent_name);
  };
}

sub torrent_add_peer
{
  my ($torrent_info, $peer_description) = @_;
  if ($peer_description =~ /
                             ([^\s]+)    # Peer id
                             \s+
                             ([\d.:]+)   # IP address
                             \s+
                             ([CU][in])([CU][in]) # Choked-interested
                             \s+
                             (\d+)       # Download rate
                             \s+
                             (\d+)       # Upload rate
                             \s+
                             (\d+)       # Downloaded
                             \s+
                             (\d+)       # Uploaded
                             \s+
                             (\d+)       # pieces
                           /x) {
    push(@{$torrent_info->{incoming_peers} ||= []},
         {id            => $1,
          address       => $2,
          remote_flags  => $3,
          local_flags   => $4,
          download_rate => $5,
          upload_rate   => $6,
          downloaded    => $7,
          uploaded      => $8,
          pieces        => $9});
  }
}

sub torrent_set_manual_bandwidth_limit
{
  my ($torrent, $direction, $limit) = @_;
  $torrent->{"manual_${direction}_limit"} = $limit;
  torrent_set_bandwidth_limit($torrent, $direction, $limit);
}

sub torrent_set_bandwidth_limit
{
  my ($torrent, $direction, $limit) = @_;
  my $message = ($direction eq 'upload') ? 'U' : 'D';
  my $client = get_client_by_id($torrent->{ctcs_id});
  if ($direction eq 'upload')
  {
    $torrent->{upload_limit} = $limit;
  }
  elsif ($direction eq 'download')
  {
    $torrent->{download_limit} = $limit;
  }
  else
  {
    ctcs_log(LOG_WARNING,
             "Cannot set bandwidth for unknown direction '$direction'");
    return;
  }
  ctcs_log(LOG_INFO,
           q(Setting %s limit of '%s' to %d),
           $direction,
           $torrent->{name},
           $limit);
  send_message(sprintf("SET${message}LIMIT %.0f\r\n", $limit), $client);
}

sub torrent_quit
{
  send_message("CTQUIT\r\n", get_client_by_id((shift)->{ctcs_id}));
}

sub torrent_update
{
  send_message("CTUPDATE\r\n", get_client_by_id((shift)->{ctcs_id}));
}

sub torrent_pause
{
  torrent_set_config(shift, 'pause', 1);
}

sub torrent_is_paused
{
  my ($torrent) = @_;
  return $torrent->{config}->{pause}->{value} == 1;
}

sub torrent_resume
{
  torrent_set_config(shift, 'pause', 0);
}

sub torrent_set_config
{
  my ($torrent, $config_option, $value) = @_;

  ctcs_log( LOG_DEBUG, 'Setting config option %s of %s to %s', $config_option, $torrent->{name}, $value );

  return unless
  exists($torrent->{config}->{$config_option}->{validator})    &&
  $torrent->{config}->{$config_option}->{validator}->($value);

  ctcs_log( LOG_DEBUG, 'Config change validated.  Applying.' );

  my $client = get_client_by_id($torrent->{ctcs_id});
  if (!defined($client))
  {
    ctcs_log(LOG_WARNING,
             q(Cannot set config on torrent '%s': it has no active connection),
             $torrent->{name});
    return;
  }
  else
  {
    ctcs_log(LOG_INFO,
             q(Setting config option '%s' of '%s' to '%s'),
             $config_option, $torrent->{name}, $value);
  }
  send_message(sprintf("CTCONFIG %s %s\r\n", $config_option, $value), $client);
  torrent_request_config_from($client);
}

###############################################################################
# Given a number that is assumed to be a number of bytes, returns a string
# that truncates that number with a useful suffix (i.e. 'MB' or 'GB').
# If a format specifier is given, it is used the format the number.  If an
# additional 'small format' specifier is given, it is used instead of the
# normal specifier if the number is less than 10.
###############################################################################

sub human_readable
{
  my $number       = shift;
  my $format       = shift || 'd';
  my $small_format = shift || $format;

  return '' if !defined($number);
  $number          = $1 if $number =~ /(\d+)/;

  my @range   = ('B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB'); # Future proofing...
  my $current = 0;
  ($number /= 1024) && $current++ while $number > 1024;

  return $number < 10 ?
  sprintf("%$small_format %s", $number, $range[$current]) :
  sprintf("%$format %s", $number, $range[$current]);
}

###############################################################################
# A bit of profiling on FreeBSD showed that gethostbyaddr is quite expensive,
# and invoking it every time a message is received (for the debug log)
# actually ramped up CPU time to almost twice what it was versus this caching
# version
###############################################################################

sub address_of
{
  my $client = shift;
  unless (exists $clients{$client}->{address})
  {
    $clients{$client}->{address} = $client->opened() ?
    (gethostbyaddr($client->peeraddr(), AF_INET))[0] :
    'CLOSED';
  }
  return $clients{$client}->{address};
}

sub peer_count_for
{
  my $info = torrent_handled_by(shift);
  return scalar @{$info->{peers}}
}

sub torrent_summary
{
  my $torrent = shift;
  my $level   = shift || SUMMARY_BRIEF;
  my $data    = { 'id' => $torrent->{ctcs_id}, 'name' => $torrent->{name} };

  if ( $level == SUMMARY_FULL )
  {
    $data->{percent_complete} = $torrent->{percent_complete};
    $data->{time_remaining}   = calculate_time_remaining($torrent->{downloaded_chunks},
                                                         $torrent->{total_chunks},
                                                         $torrent->{piece_size},
                                                         smoothed_dl_rate($torrent));
    $data->{download_rate}    = human_readable($torrent->{download_rate}) . '/s';
    $data->{upload_rate}      = human_readable($torrent->{upload_rate}) . '/s';
    $data->{seeders}          = $torrent->{active_seeders} . '/' . $torrent->{total_seeders};
    $data->{leechers}         = $torrent->{active_leechers} . '/' . $torrent->{total_leechers};
    $data->{downloaded}       = human_readable($torrent->{downloaded}, '0.2f');
    $data->{uploaded}         = human_readable($torrent->{uploaded}, '0.2f');
    $data->{size}             = human_readable($torrent->{size}, 'd', '0.2f');
    $data->{ratio}            = formatted_ratio_for($torrent);
    $data->{paused}           = torrent_is_paused($torrent) ? '1' : '0';
  }

  return $data;
}

###############################################################################
# apicall is a bit of a tongue-twister.  It should be given a block to execute
# when it is triggered.  This block will be fed four parameters in @_ when it
# is called:
#
# - the HTTP params associated with the request that triggered the call
# - a list reference of torrents (elements of the %clients hash)
# - the client socket that triggered the request, in case an answer is required
# - a flag indicating whether the torrents list being fed into the block
#   was formed explicitly (from the HTTP parameters) or implicitly (taking all
#   registered torrents in the absence of specific instructions).
# blocks fed to apicall have a simple contract: if you succeed, simply return
# the data structure (normally a hash reference) to be encoded and sent back
# to the client.  If you fail for whatever reason, die with a message
# explaining why.  The wrapper function generated by apicall will handle
# the rest.
#
# The function returned by apicall expects to be called with two paramters:
#
# - the HTTP parameters for the actual request triggering the call
# - the client socket that initiated the call.
# - the name of the call (i.e. 'pause', 'resume', 'set-config', etc.)
#
###############################################################################

sub apicall(&)
{
  my $fun = shift;
  return sub {
    my $params = shift;
    my $socket = shift;
    my $name   = shift;
    my @torrents;
    my $explicit_parameters = 0;
    if ( exists($params->{torrents}) )
    {
      ctcs_log( LOG_DEBUG, 'API call taking torrent IDs from explicit parameters \'%s\'', $params->{torrents} );
      foreach my $id (split(/,/, $params->{torrents}))
      {
        my $torrent = get_torrent_by_id($id);
        push(@torrents, $torrent) if $torrent;
      }
      $explicit_parameters = 1;
    }
    else
    {
      ctcs_log( LOG_DEBUG, 'API call using all torrent clients' );
      @torrents = all_torrents();
    }
    my $response_data = undef;
    eval {
      $response_data = $fun->($params, \@torrents, $socket, $explicit_parameters);
    };
    $response_data ||= {};
    chomp $@ if $@;
    $response_data->{status}  = ($@ ? 'failure' : 'success');
    $response_data->{message} = $@ if $@;
    $response_data->{action}  = $name;
    return json_encode($response_data);
  };
}

sub setup_api
{
  my $server = shift;
  my $api = $server->{api} = {};

  ##############################################################################
  # The block given to apicall is given four parameters in @_:
  # - the HTTP parameters of the request that triggered the call
  # - a list reference of torrent instances (elements of the %clients hash)
  # - a client socket that initiated the request
  # - a boolean flag indicating whether the torrent list is expicit or assumed
  ##############################################################################

  $api->{pause}   = apicall {
    my @paused    = map { torrent_pause($_); torrent_summary($_); } @{$_[1]};
    return { 'torrents' => \@paused };
  };
  $api->{resume}  = apicall {
    my @resumed   = map { torrent_resume($_); torrent_summary($_) } @{$_[1]};
    return { 'torrents' => \@resumed };
  };
  $api->{update}  = apicall {
    my @updated   = map { torrent_update($_); torrent_summary($_) } @{$_[1]};
    return { 'torrents' => \@updated };
  };
  $api->{count}   = apicall {
    return { 'count' => scalar @{$_[1]} };
  };
  $api->{'torrent-status'} = apicall {
    my @statuses = status_of_multiple_torrents(@{$_[1]});
    return { 'torrent-status' => \@statuses };
  };

  $api->{exit}    = apicall {
    # Need to write out the response immediately, as we're about to quit.
    print { $_[2] } prepare_http_message(json_encode({'action' => 'CTCS exiting', 'status' => 'success'}));
    exit(0);
  };

  $api->{quit}        = apicall {
    die "explicit torrent ids are required for the quit API call\n" unless $_[3];
    my @quit = map { torrent_quit($_); torrent_summary($_) } @{$_[1]};
    return { 'torrents' => \@quit };
  };

  $api->{paused}  = apicall {
    my @paused    = map { torrent_summary($_) } grep { torrent_is_paused($_) } @{$_[1]};
    return { 'torrents' => \@paused, 'count' => scalar @paused };
  };

  $api->{active}  = apicall {
    my @active    = map { torrent_summary($_) } grep { !torrent_is_paused($_) } @{$_[1]};
    return { 'torrents' => \@active, 'count' => scalar @active };
  };

  $api->{torrents} = apicall {
    my @torrents   = map { torrent_summary($_) } @{$_[1]};
    return { 'torrents' => \@torrents, 'count' => scalar @torrents };
  };

  $api->{'get-bandwidth-limits'} = apicall {
    return { 'upload-limit' => $ctcs{upload_limit}, 'download-limit' => $ctcs{download_limit} };
  };

  $api->{'set-bandwidth-limits'} = apicall {
    my $upload_limit   = $_[0]->{'upload-limit'};
    my $download_limit = $_[0]->{'download-limit'};
    if ( defined($download_limit) && $download_limit =~ /^0*\d+$/ )
    {
      $ctcs{download_limit} = $download_limit;
      ctcs_log( LOG_INFO, 'Setting download limit to %d', $download_limit);
    }
    if ( defined($upload_limit) && $upload_limit =~ /^0*\d+$/ )
    {
      $ctcs{upload_limit} = $upload_limit;
      ctcs_log( LOG_INFO, 'Setting upload limit to %d', $upload_limit);
    }
    autobalance_bandwidth();
    return { 'upload-limit' => $ctcs{upload_limit}, 'download-limit' => $ctcs{download_limit} };
  };

  $api->{'get-bandwidth-totals'} = apicall {
    my ($download_rate, $upload_rate) = total_used_bandwidth();
    return { 'download-rate' => $download_rate, 'upload-rate' => $upload_rate };
  };

  $api->{'set-config'} = apicall {
    die "set-config API call requires a single active torrent id\n" if scalar @{$_[1]} != 1;
    my $torrent     = $_[1]->[0]; # Only one torrent can have its config at the moment
    # Config changes are not realised internally at once.  Instead, the the connected torrent
    # is asked to supply its altered config as part of its communications with the server
    # (besides, each config change simply adds to a write request queue for the connected
    # torrent, so even the change itself won't be requested until later)
    # In order to be able to respond to THIS request with an adjusted config, I take a
    # copy of what the config is and pre-emptively apply the changes to the copy.
    # This is technically lying.
    my %config_copy = %{$torrent->{config}};
    foreach my $key (keys %{$torrent->{config}})
    {
      if ( exists($_[0]->{$key}) && torrent_set_config( $torrent, $key, $_[0]->{$key} ) )
      {
        $config_copy{$key}->{value} = $_[0]->{$key};
      }
    }
    return { 'torrent' => $torrent->{name},
             'id'      => $torrent->{ctcs_id},
             'config'  => \%config_copy };
  };

  $api->{'get-config'} = apicall {
    my @configs;
    foreach my $torrent (@{$_[1]})
    {
      push(@configs, { 'torrent' => $torrent->{name},
                       'id'      => $torrent->{ctcs_id},
                       'config'  => $torrent->{config} });
    }
    return { 'configs' => \@configs };
  };
  $api->{'set-log-level'} = apicall {
    my $log_level = $_[0]->{'log-level'};
    return ( $log_level =~ /^\d+$/ && $log_level >= LOG_MIN && $log_level <= LOG_MAX ) ?
    {
     'log-level' => ($ctcs{log_level} = $log_level) } :
     die sprintf(qq(set-log-level must be an integer from %s (most verbose) to %s (least verbose), not '%s'\n),
                 LOG_MIN, LOG_MAX, $log_level);
  };
  $api->{'get-log-level'} = apicall {
    return { 'log-level' => $ctcs{log_level} };
  };

  $api->{api} = apicall {
    my @apifuns = keys %{$api};
    return { 'api' => \@apifuns };
  };
}

sub javascript
{
  #############################################################################
  # Yes, my JavaScript is poor: a better scripter than I should refactor this
  # entire block of code at the earliest opportunity
  #############################################################################

  my $script=<<'END_JS';
  var xmlHttp = null;

  function ajaxObject()
  {
    if (xmlHttp) return xmlHttp;
    try {
      /* Firefox, Opera 8.0+, Safari */
      xmlHttp=new XMLHttpRequest();
    }
    catch (e) {
      /* Internet Explorer */
      try {
        xmlHttp=new ActiveXObject("Msxml2.XMLHTTP");
      }
      catch (e) {
        try {
          xmlHttp=new ActiveXObject("Microsoft.XMLHTTP");
        }
        catch (e) {
          return false;
        }
      }
    }
    return xmlHttp;
  }

  function update_with_current_status()
  {
    var xmlHttp = ajaxObject();

    if(!xmlHttp) return;

    if (document.getElementById('auto-refresh').checked)
    {
      xmlHttp.onreadystatechange = function() {
        if (xmlHttp.readyState == 4 && xmlHttp.responseText) {
          data = eval('(' + xmlHttp.responseText + ')');
          document.getElementById('download-bandwidth').innerHTML = data["download"];
          document.getElementById('upload-bandwidth').innerHTML = data["upload"];
          var torrent_data = data["torrents"];
          for (var i = 0; i < torrent_data.length; i++)
          {
            var torrent = torrent_data[i];
            var row_id = torrent["id"];
            var row;

            /* If the row's already there, update it. */

            row = document.getElementById(row_id);
            if (row)
            {
              update_torrent_row(row, row_id, torrent);
            }
            else /* the row's not there: create it. */
            {
              add_new_torrent(torrent);
            }
          }
          cleanup_dead_torrents(torrent_data);
          sort_torrents_table();
        }
      };
      xmlHttp.open("GET", "/current-status");
      xmlHttp.send(null);
    }
    setTimeout('update_with_current_status()', 5000);
  }

  function update_torrent_row(row, row_id, torrent)
  {
    var completed = parseInt(torrent['percent_complete']) == 100;
    var ratio_element;
    var ratio_colour;
    var ratio;
    var green;
    var red;

    if (completed && row.className.search(/complete/) == -1)
    {
      row.className += ' complete';
    }
    document.getElementById('percent_complete-' + row_id).innerHTML = torrent["percent_complete"] + '%';
    document.getElementById('time_remaining-' + row_id).innerHTML = torrent["time_remaining"];
    document.getElementById('download_rate-' + row_id).innerHTML = torrent["download_rate"];
    document.getElementById('upload_rate-' + row_id).innerHTML = torrent["upload_rate"];
    document.getElementById('seeders-' + row_id).innerHTML = torrent["seeders"];
    document.getElementById('leechers-' + row_id).innerHTML = torrent["leechers"];
    document.getElementById('downloaded-' + row_id).innerHTML = torrent["downloaded"];
    document.getElementById('uploaded-' + row_id).innerHTML = torrent["uploaded"];
    document.getElementById('size-' + row_id).innerHTML = torrent["size"];
    ratio_element = document.getElementById('ratio-' + row_id);
    ratio_element.innerHTML = torrent["ratio"] == "Inf." ? "Inf." : torrent["ratio"].toFixed(2);
    if (torrent["paused"] == '1' && row.className.search(/paused/) == -1)
    {
      row.className = row.className + ' paused';
      var pause_option = document.getElementById('pause_unpause-' + row_id);
      pause_option.text = 'Resume';
      pause_option.value = 'Resume';
    }
    else if (torrent["paused"] == '' && row.className.search(/paused/) >= 0)
    {
      row.className = row.className.replace(/paused/, '');
      var pause_option = document.getElementById('pause_unpause-' + row_id);
      pause_option.text = 'Pause';
      pause_option.value = 'Pause';
    }
    if (torrent["ratio"] == "Inf.")
    {
      red = 0;
      green = 255;
    }
    else
    {
      ratio = parseFloat(torrent["ratio"]);
      red = 255 - (ratio * 255);  if (red < 0.0) red = 0.0;
      green = ratio * 128; if (green > 255) green = 255;
    }
    var colour = '' + ((red << 16) | (green << 8) | 0).toString(16);
    while(colour.length < 6) colour = '0' + colour;
    ratio_element.style.color = '#' + colour;
  }


  function add_new_torrent(torrent)
  {
    var torrents_table = document.getElementById('torrents');
    var cell_count = torrent.length + 1; /* the +1 is for the action form at the end. */
    var new_row = torrents_table.insertRow(torrents_table.rows.length);
    var completed = parseInt(torrent["percent_complete"]) == 100;

    new_row.id = torrent["id"];
    new_row.className = (torrents_table.rows.length % 2 == 0) ? 'torrent-even' : 'torrent-odd';
    if (completed) new_row.className += ' complete';

    torrent_link = document.createElement('a');
    torrent_link.href = '/torrent/' + escape(torrent["id"]);
    torrent_link.innerHTML = torrent["name"];

    var title_cell = new_row.insertCell(0);
    title_cell.className = 'title';
    title_cell.appendChild(torrent_link);

    var fields = ["percent_complete", "time_remaining", "download_rate", "upload_rate",
                  "seeders", "leechers", "downloaded", "uploaded", "size", "ratio"];
    var torrent_id = torrent["id"];

    for (var i = 0; i < fields.length; i++)
    {
      var cell = new_row.insertCell(i + 1);
      cell.id = fields[i] + "-" + torrent_id;
      cell.innerHTML = torrent[fields[i]];
      if (fields[i] == "percent_complete") cell.innerHTML += '%';
    }

    var action_form = document.createElement('form');
    action_form.method = "post";
    action_form.action = "/status-action";
    action_form.encoding = 'application/x-www-form-urlencoded';

    var action_select = document.createElement('select');
    action_select.name = 'action';

    var pause_unpause = (torrent["paused"] == 1) ? "Resume" : "Pause";
    var options = [ pause_unpause, "Update", "Quit"];

    for (var i = 0; i < options.length; i++)
    {
      var option = document.createElement('option');
      option.text = options[i];
      option.value = options[i];
      if (options[i] == 'Pause' || options[i] == 'Resume') option.id = 'pause_unpause-' + torrent_id;
      action_select.add(option, null);
    }

    var submit_button = document.createElement('input');
    submit_button.type = 'submit';
    submit_button.value = 'Ok';
    submit_button.name = 'submit';

    var hidden  = document.createElement('input');
    hidden.type = 'hidden';
    hidden.name = 'torrent-id';
    hidden.value = torrent["id"];

    action_form.appendChild(hidden);
    action_form.appendChild(action_select);
    action_form.appendChild(submit_button);

    var form_cell = new_row.insertCell(fields.length + 1);
    form_cell.appendChild(action_form);
  }

  function sort_torrents_table()
  {
    var table = document.getElementById('torrents');
    var rows = table.rows;
    var new_rows = new Array(rows.length - 1);
    for (var i = 0; i < new_rows.length; i++) new_rows[i] = rows.item(i + 1);
    new_rows.sort(function(a, b) {
      var first_percent = parseInt(a.cells[1].innerHTML);
      var second_percent = parseInt(b.cells[1].innerHTML);
      return second_percent - first_percent;
    });
    while(table.rows.length > 1) table.deleteRow(1);

    /* Now that I've gone and re-sorted everything, the row colours are most
       likely screwed, so they need re-adjusting */

    for (var i = 0; i < new_rows.length; i++)
    {
      var current_class = new_rows[i].className;
      var new_class = (i % 2 == 0) ? 'torrent-even' : 'torrent-odd';
      current_class = current_class.replace(/torrent-(even|odd)/, new_class);
      new_rows[i].className = current_class;
      table.appendChild(new_rows[i]);
    }
  }

  function cleanup_dead_torrents(torrent_data)
  {
    /* Finally, go through the rows in the table and delete any that are not in the incoming data */
    var table = document.getElementById('torrents');
    var index = 1; /* Exclude the headings */
    while(index < table.rows.length)
    {
      var id = table.rows[index].id;
      var found = 0;
      for (var i = 0; i < torrent_data.length; i++) if (torrent_data[i]["id"] == id) found = 1;
      if (found) index++;
      else table.deleteRow(index);
    }
  }
END_JS

  return $script;
}

###############################################################################
# The stylesheet that every page should use.
###############################################################################

sub stylesheet
{
  my $sheet = <<'END_CSS';
body { font-family: Arial, sans-serif; margin-left: 5%; margin-right: 5%; margin-top: 0%; margin-bottom: 5%; }
#title { text-align: center; }
.torrent-even, .peer-even, .file-even { background-color: #ded; }
.torrent-odd, .peer-odd, .file-odd, div#global-bandwidth-limits { background-color: #efe; }
div#global-bandwidth-limits { width: 100%; padding-top: 1em; padding-bottom: 1em; }
div#global-bandwidth-limits table { margin-left: auto; margin-right: auto; }
div#global-bandwidth-limits table th { text-align: left; }
table#torrents { margin-top: 3em; }
table#torrents, table#files, table#peers, table#config {width: 100%; border-collapse: collapse; margin-left: auto; margin-right: auto; font-size: smaller; }
table#files { width: auto; }
.torrent-even, .peer-even, .file-even { border-width: 1px; border-style: solid; border-color: #cdc; border-top-color: #fff; }
.torrent-odd, .peer-odd, .file-odd { border-width: 1px; border-style: solid; border-color: #bcb; border-top-color: #efe; }
td { text-align: center; }
td.title { text-align: left; }
#upload-bandwidth, .excellent-ratio { color: #3b3; }
.good-ratio { color: #292; }
.ok-ratio { color: #992; }
#download-bandwidth, .poor-ratio { color: #a22; }
#upload-bandwidth, #download-bandwidth { font-weight: bold; }
td.seed, td.leech, .paused { opacity: 0.5; }
td.seed { width: 1em; background-color: #3b3; }
td.leech { width: 1em; background-color: #a22; }
tr.complete, tr.complete a { font-weight: bold; color: green; }
END_CSS
}

sub favicon
{
  return $favicon;
}

sub setup_favicon
{
  my $ref = shift;
  my $data = '';
  my $read = 0;
  my $length = 0;

  while(defined(my $line = <DATA>))
  {
    if ($line =~ /^--favicon,(\d+) bytes$/)
    {
      $length = $1;
      last;
    }
  }

  if (!$length)
  {
    ctcs_log(LOG_WARNING, q(Unable to find '--favicon' line in data));
    return;
  }

  while (my $chunk = read(DATA, $data, $length - $read, $read))
  {
    $read += $chunk;
  }

  if ($read != $length)
  {
    ctcs_log(LOG_WARNING,
	     'Was told to expect %d bytes of favicon data, but could only read %d',
	     $length, $read);
    return;
  }

  $$ref = decode_base64($data);

  ctcs_log(LOG_INFO, 'Loaded favicon');
}

__DATA__
The format of the next line is important. --favicon marks the data that
follows as the favicon for the setup_favicon function.  The comma is
required, and the byte count should match the length of the base64
ecoded data that follows it from the next line. This is more persnickety
than it needs to be.  What can I say?  I was bored when I wrote the code.
--favicon,429 bytes
AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAMbQgAY1hGACtrJwCDeWcAYYNTADqaOABflF4AmpR/AFe6VgCyq5YAiMCFAKO+
mwDJxbYA1uDPAPX79QAAAAAA////8f///////xEzEx/////zd0QkMR///zmUAAAEEf/zy95g
AABD//nF7kIgIiMf/LXe7tvuRD98qN7avuZUP/6o7mVe4lQxnNjeaF7iVD/86O6ojuJXP/nt
7qiO5Xcf/87oiIirk///nO7bu8k//////NzMl///////n5/////+/wAA8B8AAOAHAADAAwAA
gAMAAIABAACAAQAAAAEAAIAAAAAAAQAAgAEAAIABAADAAwAAwAcAAPgPAAD9fwAA
__END__

BSD LICENCE

Copyright (c) 2009-2010 Danny Woods
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
3. The name of the author may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

HACKING GUIDE
-------------

aims
----

Externals

CTCS should remain a single file with Perl as its sole prerequisite.  This is
for ease of distribution.  At the time of this writing, Perl 5.8 is the
standard Perl on Linux, BSD, etc., so please limit language features and
modules to those available with a vanilla distribution of that version.

Internals

All state relating to a given client is in %clients, keyed by client socket.
The great advantage of this is that cleaning up all information related to a
given connection is a simple matter of grabbing hold of the socket, deleting
the %clients entry, and then closing the socket.  This greatly reduces the
chance of zombie connections.

Torrent info for an individual (torrent-supplying) client is in
$clients{a-client}->{torrent}.

All state pertaining to the server itself is in %ctcs.

Any new state added at a later date should be part of these two top-level
hashes (unless, of course, it clearly belongs to neither).

The code is single-threaded and uniprocess, and is simple, efficient and easy
to debug as a result.  Please resist the urge to change this.  Yes, periodic
updates of config information, peers, etc. would be nice in a separate thread
rather than in the top-level 'select' loop, but I would rather avoid the
headaches of synchronised access to the %clients hash.

Useful Bits
-----------

The '/debug' page on the web UI shows the current state of the core data
structures used by the program: it is extremely useful for data visualisation.

function_to_handle_request

This is the primary function for deciding how to deal with an incoming request.
For HTTP GETs and POSTs, it gets the entire request as a string.  Messages
from a ctorrent instance are a single line.
New request types will probably call for a new branch on the
conditional, with a new function to handle them.

Requests that are not implemented yield a warning in the logs, but otherwise
do not hinder the operation of the server.
