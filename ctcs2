#!/usr/bin/perl -wT
###############################################################################
#
=pod

=head1 NAME

ctcs2

=head1 SYNOPSIS

ctcs2 [--download=1000] [--upload=50] [--port=8080] [--no-log-times] [--help]

=head1 DESCRIPTION

A replacement for the CTorrent Control Center
(http://www.rahul.net/dholmes/ctorrent/ctcs.html) that aims for clean code and
simple extensibility.

Many thanks to Dennis Holmes for the original CTCS code, which was used
extensively during development as a protocol reference.

=head1 COMMAND LINE OPTIONS

=over

=item --download

Sets the download limit used by the server, in KB/s.  Can be changed later
from the Web UI.  Defaults to 1000.

=item --upload

Sets the upload limit used by the server, in KB/s.  Can be changed later
from the Web UI.  Defaults to 50.

=item --port

Sets the port to listen on for ctorrent/Web connections.  Defaults to 8080

=item --no-log-times

Suppresses the printing of timestamps on log messages.  This is useful when
using CTCS2 with an external logging mechanism like daemontools' multilog, where
timestamps are automatically prepended to log lines.  Defaults to off (log
messages are timestamped)

=back

=head1 AUTHOR

Danny Woods (dannywoodz@yahoo.co.uk)

=head1 COPYRIGHT

Copyright (c) 2009-2010 Danny Woods

=head1 LICENCE

BSD

=cut
#
###############################################################################

use IO::Socket qw($CRLF AF_INET SOMAXCONN SOCK_STREAM);
use IO::Select;
use IO::String;
use Socket 'TCP_NODELAY';
use Errno 'EAGAIN';
use CGI qw(:standard);
use Getopt::Long;
use POSIX qw(strftime);
use Data::Dumper;
use strict;
use warnings;
use diagnostics;
use constant LOG_TEMP      => 0;
use constant LOG_DEBUG     => 1;
use constant LOG_INFO      => 2;
use constant LOG_WARNING   => 3;
use constant LOG_ERROR     => 4;
use constant FORM_ENCODING => 'application/x-www-form-urlencoded';

$SIG{INT}  = \&cleanup;
$SIG{TERM} = \&cleanup;
$|         = 1;                 # Autoflush STDOUT
$0         = 'ctcs2';

my $port                    = 8080;
my $download_limit          = 1000;
my $upload_limit            = 50;
my $suppress_log_timestamps = 0;
my $current_id              = 1;
my $help                    = undef;

###############################################################################
# The core data structures used by the server.
# %clients is a hash of hashes that contains information about clients, whether
# they are web browsers or ctorrent instances.  The keys are the socket
# instances themselves.  The values are sub-hashes.
#
# A typical clients hash might look like this:
#
# %clients{$socket}->{torrent}->{ctorrent_id}
#                             ->{ctcs_id}
#                             ->{name}
#                             ->{upload_rate}
#                             ->{download_rate}
#                             ->{size}
#                             ->{piece_size}
#                             ->{active_seeders}
#                             ->{total_seeders}
#                             ->{active_leechers}
#                             ->{total_leechers}
#                             ->{total_connections}
#                             ->{downloaded_chunks}
#                             ->{total_chunks}
#                             ->{available_chunks}
#                             ->{downloaded}
#                             ->{uploaded}
#                             ->{download_limit}
#                             ->{upload_limit}
#                             ->{cache_used}
#                             ->{last_status_update}
#                             ->{files}->[$n]->{name}
#                                            ->{size}
#                             ->{peers}->[$n]->{id}
#                                            ->{address}
#                                            ->{remote_flags}
#                                            ->{local_flags}
#                                            ->{download_rate}
#                                            ->{upload_rate}
#                                            ->{downloaded}
#                                            ->{uploaded}
#                                            ->{pieces}
#                             ->{config}->{$field}->{value}
#                                                 ->{type}
#                                                 ->{range}
#                                                 ->{short_desc}
#                                                 ->{long_desc}
#
#                  ->{address}
#                  ->{messages}->[ writer-function-1 ... writer-function-n ]
#
# Web clients don't have the 'torrent' subhash: that is only available for
# ctorrent clients.
#
# %ctcs contains information about the server: global upload limit, download
# limit, uptime, etc.  This information is relevant to the server, and NOT
# any individual torrent.
#
# Occasionally, it's useful to find a client socket using the torrent name:
# it's very tempting at this point to add another hash that has this mapping,
# but really, the cost of searching is minimal, and not worth the additional
# headaches of making sure that everything's correctly cleaned up.  The good
# thing about this structure is that when a socket is closed, it's just
# a matter of deleting it from the %clients hash to get rid of all associated
# information.
###############################################################################

my %clients;
my %ctcs;
my %api;

###############################################################################
# Command-line options
###############################################################################

GetOptions('port=i'       => \$port,
           'download=i'   => \$download_limit,
           'upload=i'     => \$upload_limit,
           'no-log-times' => \$suppress_log_timestamps,
           'help'         => \$help);

###############################################################################
# Usage
###############################################################################

if ($help)
{
  eval "use Pod::Text;";
  pod2text($0);
  exit(0);
}

###############################################################################
# The server socket, and activity handles to be used later in a select call.
###############################################################################

my $server = IO::Socket::INET->new(LocalPort => $port,
                                   ReuseAddr => 1,
                                   Type      => SOCK_STREAM,
                                   Blocking  => 0,
                                   Proto     => 'tcp',
                                   Listen    => SOMAXCONN) || die $!;

my $readers  = IO::Select->new();
my $writers  = IO::Select->new();

$readers->add($server);

###############################################################################
# Setup defaults for the server
###############################################################################

$ctcs{download_limit}       = $download_limit * 1024;
$ctcs{upload_limit}         = $upload_limit * 1024;
$ctcs{accepted_connections} = 0;
$ctcs{closed_connections}   = 0;
$ctcs{port}                 = $port;
$ctcs{log_timestamps}       = !$suppress_log_timestamps;
$ctcs{log_level}            = LOG_INFO;
$ctcs{log_file_handle}      = \*STDOUT;
$ctcs{auto_refresh}         = 1;

###############################################################################
# Setup the API.
###############################################################################

###############################################################################
# apicall is a bit of a tongue-twister.  It should be given a block to execute,
# and a name to be associated with.  It doesn't actually do anything, but
# insteads builds and returns a function that's suitable for answering
# requests.
#
# This returned function expects to be called with three parameters:
# - the HTTP params associated with the request that triggered the call
# - a list reference of torrents (elements of the %clients hash)
# - the client socket that triggered the request, in case an answer is required
#
# What the returned function *does* is entirely up to the block that is given
# to apicall:  that block is invoked with the above parameters.
#
# The list of torrents will either be the complete list of those registered
# with the server, or a list filtered by the 'torrents' parameter of the given
# HTTP parameters (which itself should be a comma-separated list of ids).
###############################################################################

sub apicall(&$)
{
  my ($fun, $name) = @_;
  return sub {
    my $params = shift;
    my $socket = shift;
    ctcs_log( LOG_INFO, "Processing API call '%s'", $name );
    my @torrents;
    my $explicit_parameters = 0;
    if ( exists($params->{torrents}) )
    {
      ctcs_log( LOG_DEBUG, 'API call taking torrent IDs from explicit parameters \'%s\'', $params->{torrents} );
      foreach my $id (split(/,/, $params->{torrents}))
      {
	my $torrent = get_torrent_by_id($id);
	push(@torrents, $torrent) if $torrent;
      }
      $explicit_parameters = 1;
    }
    else
    {
      ctcs_log( LOG_DEBUG, 'API call using all torrent clients' );
      @torrents = all_torrents();
    }
    $fun->($params, \@torrents, $socket, $explicit_parameters);
  };
}

###############################################################################
# Functions returned by apicall have four parameters:
# - the HTTP parameters of the request that triggered the call
# - a list reference of torrent instances (elements of the %clients hash)
# - a client socket that initiated the request
# - a boolean flag indicating whether the torrent list is expicit or assumed
###############################################################################

$api{pause}   = apicall { torrent_pause($_)  for @{$_[1]} } 'pause';
$api{resume}  = apicall { torrent_resume($_) for @{$_[1]} } 'resume';
$api{update}  = apicall { torrent_update($_) for @{$_[1]} } 'update';
$api{count}   = apicall { send_http_message(scalar @{$_[1]}, $_[2]) } 'count';
$api{exit}    = apicall { exit(0) } 'exit';
$api{quit}    = apicall {
  if ($_[3]) {
    torrent_quit($_) for @{$_[1]};
  }
} 'quit';
$api{paused}  = apicall {
  my $message = join($CRLF, map { join(':', $_->{ctcs_id}, $_->{name}) } grep { torrent_is_paused($_) } @{$_[1]});
  send_http_message($message, $_[2]);
} 'paused';
$api{active}  = apicall {
  my $message = join($CRLF, map { join(':', $_->{ctcs_id}, $_->{name}) } grep { !torrent_is_paused($_) } @{$_[1]});
  send_http_message($message, $_[2]);
} 'active';
$api{bandwidth} = apicall {
  my $upload_limit = $_[0]->{upload_limit};
  my $download_limit = $_[0]->{download_limit};
  $ctcs{download_limit} = $download_limit if $download_limit =~ /^0*\d+$/;
  $ctcs{upload_limit} = $upload_limit if $upload_limit =~ /^0*\d+$/;
  autobalance_bandwidth();
} 'bandwidth';

ctcs_log(LOG_INFO, "CTCS Server started on port $port");

###############################################################################
# Main loop
###############################################################################

for (my $last_update = time(); defined($server); )
{
  my ($readable, $writable) = IO::Select::select($readers, $writers, undef, 1);

  handle_write($_) for @$writable;
  handle_read($_)  for @$readable;

  if (time() != $last_update)
  {
    foreach my $client (torrent_clients())
    {
      my $torrent = torrent_handled_by($client);
      unless(torrent_is_paused($torrent))
      {
        torrent_update_detail($client);
        torrent_update_status($client);
        torrent_update_peers($client);
        torrent_update_config($client);
      }
      ctcs_update_bandwidth_allocation();
    }
    $last_update = time();
  }
}

cleanup();
exit(0);

###############################################################################
# Subroutines
###############################################################################

sub cleanup
{
  if ($server)
  {
    ctcs_log(LOG_INFO, "Cleaning up");
    $readers->remove($server);
    $server->close();
    undef $server;
  }
}

###############################################################################
# A read event is triggered by two things: when it appears on the server
# socket, it means that a new client is asking for permission to connect.
# Being triggered by any other socket means that it's a client socket sending
# a message
###############################################################################

sub handle_read
{
  my $socket = shift;
  if ($socket == $server)       # New client connection
  {
    register_new_client($socket->accept());
    $ctcs{accepted_connections}++;
  }
  else                          # Incoming data on a client handle
  {
    handle_request($socket);
  }
}

###############################################################################
# A new client gets a slot in the %clients hash, with an empty queue.  They
# are then added to the readers list so that a future select will reap their
# request.
###############################################################################

sub register_new_client
{
  my $client = shift;

  $client->sockopt(TCP_NODELAY, 1);
  $client->blocking(0);

  $clients{$client} = {};
  $clients{$client}->{messages} = [];
  $clients{$client}->{socket}   = $client;

  ctcs_log(LOG_INFO,
           "connection from %s:%d",
           address_of($client),
           $client->peerport());

  $readers->add($client);
}

###############################################################################
# Cleans up the resources associated with a given socket.
###############################################################################

sub deregister_client
{
  my $client   = shift;
  my $hostname = address_of($client);
  my $port     = $client->peerport();
  if (scalar @{$clients{$client}->{messages}})
  {
    ctcs_log(LOG_WARNING, "CLIENT BEING DELETED WITH A NON-EMPTY MESSAGE QUEUE");
    my $string = IO::String->new();
    $_->($string) for @{$clients{$client}->{messages}};
    ctcs_log(LOG_WARNING, ${$string->string_ref()});
  }
  delete $clients{$client};
  ctcs_log(LOG_INFO,
           "connection closed%s",
           (defined($hostname)) ? " from $hostname:$port" : "");
  $readers->remove($client) while $readers->exists($client);
  $writers->remove($client) while $writers->exists($client);
  $client->close();
  $ctcs{closed_connections}++;
}

###############################################################################
# A new client request can be triggered by one of two things: the client
# closing or actually presenting data on the wire to be read.  In the latter
# case, the client is added as a writer for a future select, and a *function*
# that will supply what to write is added to its message queue.
# If the event was triggered by client closure, nothing will be read from the
# underlying socket, so the clients can be removed from the readers list,
# its message queue destroyed and then be explicitly closed.
###############################################################################

sub handle_request
{
  my $client = shift;
  my $reader = reader_function_for($client);
  my $message = $reader->($client);

  if ($message)
  {
    ctcs_log(LOG_DEBUG, "Message from %s: '%s'", address_of($client), $message);
    eval {
      my $function = function_to_handle_request($message, $client);
      send_message_function($function, $client) if $function;
    };
    ctcs_log(LOG_WARNING, $@) if $@;
  }
  else
  {
    if ($! == EAGAIN)
    {
      ctcs_log(LOG_DEBUG, "EAGAIN is set: will handle request later");
      $! = 0;
    }
    else
    {
      my $torrent = $clients{$client}->{torrent};
      deregister_client($client);
      autobalance_bandwidth() if $torrent;
    }
  }
}

###############################################################################
# name:        reader_function_for
# description: Returns a function that, when called against a given socket,
#              will return that socket's request. If the request is a simple
#              HTTP GET or ctorrent CTBW, etc., the return value is a single
#              line.  POSTs are returned in their entirety.
#              In any event, if the request cannot be read fully, this function
#              returns undef.  If it's simply an exhausted buffer, $! is set to
#              EAGAIN.  It can be called repeatedly against the same socket
#              until it either returns the message, or undef with $! != EAGAIN
# returns:     a function that should be invoked with an IO::Handle object
#              (most likely a socket)
###############################################################################

sub reader_function_for
{
  my ($socket) = @_;
  my $function = $clients{$socket}->{reader};
  if (!$function)
  {
    my $header = IO::String->new();
    my $header_read;
    my $content_length;
    my $body;
    my $line_reader = line_reader_function();
    my $do_initialise = 1;

    my $initialise = sub {
      ctcs_log(LOG_DEBUG, "Initialising reader function");
      $header->pos(0);
      $header_read    = 0;
      $content_length = 0;
      $body = '';
      $do_initialise = 0;
    };

    $function = $clients{$socket}->{reader} = sub {
      my $client = $_[0];
      my ($line, $result);

      $initialise->() if $do_initialise;

      while (!$header_read && defined($line = $line_reader->($client)))
      {
        return $line if $line !~ /^(?:POST|GET)/ && $header->pos() == 0;
        $content_length = $1 if $line =~ /^Content-Length: (\d+)/;
        ctcs_log(LOG_DEBUG, "Header line: '%s'", $line);
        print $header $line, "\n";
        $header_read = 1 if $line eq '';
      }
      return undef unless $header_read;

      ctcs_log(LOG_DEBUG, "Content-Length: %s", $content_length);
      ctcs_log(LOG_DEBUG, "BEFORE: Length of body is %d", length($body));

      while ($content_length > 0 &&
             length($body) < $content_length &&
             defined($result = $line_reader->($client, $content_length))) {
        last unless $result;
        $body = $result;
      }

      ctcs_log(LOG_DEBUG, "AFTER: Length of body is %d", length($body));
      ctcs_log(LOG_DEBUG, "Body is '%s'", $body);

      return undef if (!defined($result) && length($body) < $content_length);
      return undef unless length($body) == $content_length;

      ctcs_log(LOG_DEBUG, "Body: %s", $body);

      print $header $body if $body;

      $do_initialise = 1;

      return ${$header->string_ref()};
    }
  }
  return $function;
}

###############################################################################
# name:        writer_function
# description: returns a function that, when given an IO handle, will write
#              the return value of the function given to writer_function onto
#              it (pause and think about that for a second: I definitely needed
#              to).  The function returned will return a false value if it
#              hasn't written the entire message, or a true value if it has.
# params:      a reference to a function whose return value should be fed into
#              the function returned by this function.
# returns:     a function that takes an IO handle
###############################################################################

sub writer_function
{
  my $handler = shift;
  my $close_after_write = shift;
  my $message = $handler->() || '';
  my $message_length = defined($message) ? length($message) : 0;
  my $message_offset = 0;
  return sub {
    my $client  = shift;

    ctcs_log(LOG_DEBUG, "Writing %d bytes of length %d, starting at %d",
             $message_length - $message_offset, $message_length,
             $message_offset);

    my $written = syswrite($client,
                           $message,
                           $message_length - $message_offset,
                           $message_offset);
    if (!defined($written))
    {
      ctcs_log(LOG_WARNING,
               "Failed to write message '%s', starting at index %d",
               $message,
               $message_length - $message_offset);
      return 1; # The message is effectively finished if it has errored
    }

    ctcs_log(LOG_DEBUG, "Wrote %d bytes of a %d byte message",
             $written, $message_length);

    $message_offset += $written;
    my $finished = ($message_offset == $message_length);

    ctcs_log(LOG_DEBUG,
             "Wrote %d bytes, leaving %d remaining. Message is%s finished",
             $written, $message_length - $message_offset, $finished ? "" : " NOT");

    if ($close_after_write && $finished)
    {
      shift(@{$clients{$client}->{messages}});
      deregister_client($client);
    }

    return $finished;
  }
}

###############################################################################
# Writing is simple: for a given socket, it has a queue of functions in the
# 'messages' subhash.  Each of these functions will return true if they finish
# sending, and false otherwise.  Each function should be a writer_function that
# wraps a content generating function: the writer function keeps track of how
# much of a given message that it has sent, so it needn't be tracked here.
###############################################################################

sub handle_write
{
  my $client = shift;
  my $messages = $clients{$client}->{messages};

  while ($messages && @$messages)
  {
    my $function = $messages->[0];
    last if !$function->($client);
    shift(@$messages);
  }
  $writers->remove($client) unless ($messages && @$messages);
}

###############################################################################
# This is the big decision maker: given a message, it needs to return a
# writer_function that wraps some content generating function.  The content
# generating function needs to return a string.
###############################################################################

sub function_to_handle_request
{
  my ($message, $client) = @_;

  $_ = $message;

  if (/^CTBW\s+(\d+),\s*(\d+)\s+(\d+),\s*(\d+)/)
  {
    record_bandwidth($client, $1, $2);
  }
  elsif (/^CTPEER\s+(.*)/)
  {
    torrent_add_peer(torrent_handled_by($client), $1);
  }
  elsif (/^CTCONFIG\s+(.*)/)
  {
    torrent_store_config(torrent_handled_by($client), $1);
  }
  elsif (/^CTFILE\s+(.*)/)
  {
    ctcs_log(LOG_DEBUG, "Got a file: %s", $1);
    torrent_populate_file_info(torrent_handled_by($client), $1);
  }
  elsif (/^CTPEERSTART/)
  {
    $clients{$client}->{torrent}->{incoming_peers} = [];
  }
  elsif (/^CTPEERSDONE/)
  {
    my $torrent = torrent_handled_by($client);
    ctcs_log(LOG_INFO, "Received %d peers for '%s'",
             peer_count_for($client),
             $torrent->{name});
    $torrent->{peers} = $torrent->{incoming_peers};
    delete $torrent->{incoming_peers};
    $torrent->{last_peers_update} = time();
  }
  elsif (/^CTSTATUS\s+(.*)/)
  {
    my $torrent_info = torrent_handled_by($client);
    torrent_set_status($torrent_info, $1);
    return exists($torrent_info->{size}) ?
    undef :
      writer_function(\&ctcs_request_detail_command);
  }
  elsif (/^CTDETAIL\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/)
  {
    my $torrent_info = torrent_handled_by($client);
    $torrent_info->{size}       = $1;
    $torrent_info->{piece_size} = $2;
    $torrent_info->{time_now}   = $3;
    $torrent_info->{time_seed}  = $4;
  }
  elsif (/^CTORRENT\s+([^\s]+)(?:\s+(\d+)\s+(\d+)\s+(.*))?/)
  {
    handle_register_torrent($client, $1, $2, $3, $4);
    autobalance_bandwidth();
    return writer_function( sub { ctcs_protocol() . "\r\n" });
  }
  elsif (/^GET\s+([^\s]+)/)
  {
    my $target = $1;
    my $close_after_write = $message =~ /Connection: close/i;
    return writer_function(sub { handle_send_page($target, $client) }, $close_after_write);
  }
  elsif (/^POST\s+([^\s]+)/)
  {
    my $target = $1;
    return writer_function(sub { handle_form_submission($target, $client, $_)}, 1);
  }
  elsif (/^DUMP\s*$/)
  {
    return writer_function(\&handle_dump);
  }
  elsif (/^PROTOCOL\s+0*(\d+)/)
  {
    $ctcs{protocol} = $1;
  }
  elsif (/^CTFILESDONE|CTFILESTART|CTCONFIGSTART|CTCONFIGDONE|CTINFO/)
  {
    # Nothing: just here to avoid triggering the following exception
  }
  else
  {
    die "No function to handle request '$message'\n";
  }
  return undef;
}

###############################################################################
# This is a simple convenience utility.  Given a block of code, any 'print'
# or 'write' statements *not* directed at a specific filehandle will instead
# be collected in a string that is returned when the function completes.
###############################################################################

sub with_output_to_string(&)
{
  my $function = shift;
  my $string = IO::String->new();
  my $oldfd = select $string;
  my $oldflush = $|;
  $| = 1;
  eval { $function->() };
  $| = $oldflush;
  select $oldfd;
  warn if $@;
  return ${$string->string_ref()};
}

###############################################################################
# Given a location, this function should return a string that represents the
# content of that location
###############################################################################

sub handle_send_page
{
  my ($location, $client) = @_;
  my $response_code;
  my $page;
  my $plain = 0;
  my $page_content = page_content($location, \$plain);

  #############################################################################
  # A request that sets $$plain to a true value is most likely a handler for
  # an AJAX request.  This flag indicates that the content should *not* be
  # wrapped up in an HTML head, body, etc, but should just go out as-is with
  # an HTTP header slapped on top.
  #############################################################################

  if ($page_content)
  {
    $page = with_output_to_string {
      if ($plain)
      {
        print $page_content;
      }
      else
      {
        print start_html(-title => 'CTCS 2',
                         -script => javascript(),
                         -head => style({type => 'text/css'},
                                        stylesheet())),
                                        $page_content,
                                        end_html();
      }
    };
    $response_code = '200 OK';
  }
  else
  {
    $page = with_output_to_string {
      print start_html({title => 'CTCS 2 - Page Not Found'}),
      error_page($location),
      end_html();
    };
    $response_code = '404 Not Found';
  }

  return join('',
              ("HTTP/1.1 $response_code\r\n",
               header({content_length => length($page)}),
               $page));
}

sub handle_form_submission
{
  my ($target, $client, $request) = @_;
  my $query = CGI->new(IO::String->new($request));

  ctcs_log(LOG_DEBUG, $request);

  if ($target eq "/")
  {
    my $upload_limit              =  $query->param('ulimit');
    my $download_limit            =  $query->param('dlimit');
    my $auto_refresh              =  $query->param('auto-refresh');
    $ctcs{download_limit}         =  (int($download_limit) * 1024) if defined $download_limit;
    $ctcs{upload_limit}           =  (int($upload_limit) * 1024) if defined $upload_limit;
    $ctcs{auto_refresh}           =  ($auto_refresh && int($auto_refresh)) || 0;
    autobalance_bandwidth();
    return with_output_to_string {
      print "HTTP/1.1 302 Found\r\n";
      print $query->redirect(-uri => '/');
    }
  }
  elsif ($target eq "/status-action")
  {
    my $action  = $query->param('action');
    my $id      = CGI::unescape($query->param('torrent-id'));
    my $torrent = get_torrent_by_id($id);

    torrent_pause($torrent)  if $action eq 'Pause';
    torrent_resume($torrent) if $action eq 'Resume';
    torrent_quit($torrent)   if $action eq 'Quit';
    torrent_update($torrent) if $action eq 'Update';

    return with_output_to_string {
      print "HTTP/1.1 302 Found\r\n";
      print $query->redirect(-uri => '/');
    }
  }
  elsif ($target eq '/set-config')
  {
    my $params = $query->Vars;
    my $id = $params->{'torrent-id'};
    my $page = $id ? "/torrent/$id" : '/';
    my $torrent = get_torrent_by_id(CGI::unescape($id));
    my $config = $torrent->{config};

    foreach my $option (keys %$config)
    {
      #########################################################################
      # A mising boolean parameter indicates that the associated checkbox on
      # the form was not set.  Set it explicitly to zero.
      #########################################################################
      if (!exists($params->{$option}) && $config->{$option}->{type} eq 'B')
      {
        $params->{$option} = '0';
      }

      if ($config->{$option}->{value} ne $params->{$option})
      {
        #######################################################################
        # When changing CTCS server, *don't* go back to the info for this page:
        # it belongs to another server
        #######################################################################
        $page = "/" if $option eq 'ctcs_server';
        torrent_set_config($torrent, $option, $params->{$option});
      }
    }

    return with_output_to_string {
      print "HTTP/1.1 302 Found\r\n";
      print $query->redirect(-uri => $page);
    }
  }
  elsif ($target eq '/set-advanced-limits')
  {
    my $params = $query->Vars;
    map {
      my ($operation, $id) = split(/-/, $_, 2);

      if (defined($operation) && defined($id))
      {
        my $torrent = get_torrent_by_id(CGI::unescape($id));
        if ($operation eq 'upload' || $operation eq 'download')
        {
          unless (exists($params->{"automanage-$id"}))
          {
            torrent_set_manual_bandwidth_limit($torrent,
                                               $operation,
                                               $params->{$_} * 1024);
          }
        }
        elsif ($operation eq 'automanage')
        {
          ctcs_log(LOG_INFO,
                   "Automatically managing bandwidth allocation for '%s'",
                   $torrent->{name});
          delete $torrent->{manual_upload_limit};
          delete $torrent->{manual_download_limit};
        }
      }
    } keys %$params;
    return with_output_to_string {
      print "HTTP/1.1 302 Found\r\n";
      print $query->redirect(-uri => '/advanced-limits');
    }
  }
  elsif ($target =~ '^/api/(.*)$')
  {
    my $params = $query->Vars;
    ctcs_log(LOG_INFO, "API call '%s'", $1);
    handle_api_call($1, $params, $client);
    return "HTTP/1.1 200 OK\r\n\r\n";
  }

  return error_page($target);
}

sub handle_api_call
{
  my ($path, $params, $client) = @_;
  my $handler = $api{$path} || sub { ctcs_log(LOG_WARNING, "Unknown API call: '%s'", $path); };
  $handler->($params, $client);
}

sub page_content
{
  my ($page, $plain_ref) = @_;

  if ($page eq '/current-status')
  {
    $$plain_ref = 1;
    return json_status();
  }

  return index_page() if $page eq "/";
  return torrent_info_page($1) if $page =~ /^\/?torrent\/(.+)$/;
  return advanced_limits_page() if $page eq '/advanced-limits';
  return debug_page() if $page eq "/debug";
  return undef;
}

sub json_status
{
  my $torrent_id = shift;
  my $status = IO::String->new();
  print $status sprintf('{ "download": "%s", "upload": "%s", "torrents": [',
                        map { human_readable($_) . '/s' } total_used_bandwidth());

  printf $status join(',',
                      map {
                        my $torrent = torrent_handled_by($_);
                        sprintf(join(', ',
                                     ('{"id": "%s"',
                                      '"name": "%s"',
                                      '"percent_complete": "%s"',
                                      '"time_remaining": "%s"',
                                      '"download_rate": "%s"',
                                      '"upload_rate": "%s"',
                                      '"seeders": "%s"',
                                      '"leechers": "%s"',
                                      '"downloaded": "%s"',
                                      '"uploaded": "%s"',
                                      '"size": "%s"',
                                      '"ratio": "%s"',
                                      '"paused": "%s"}')),
                                ($torrent->{ctcs_id},
                                 $torrent->{name},
                                 $torrent->{percent_complete},
                                 calculate_time_remaining($torrent->{downloaded_chunks},
                                                          $torrent->{total_chunks},
                                                          $torrent->{piece_size},
                                                          $torrent->{smoothed_dl_rate}),
                                 human_readable($torrent->{download_rate}) . '/s',
                                 human_readable($torrent->{upload_rate}) . '/s',
                                 ($torrent->{active_seeders} . '/' . $torrent->{total_seeders}),
                                 ($torrent->{active_leechers} . '/' . $torrent->{total_leechers}),
                                 human_readable($torrent->{downloaded}, '0.2f'),
                                 human_readable($torrent->{uploaded}, '0.2f'),
                                 human_readable($torrent->{size}, 'd', '0.2f'),
                                 formatted_ratio_for($torrent),
                                 torrent_is_paused($torrent)))
                      } torrent_clients());
  print $status ']}';
  return ${$status->string_ref()};
}

###############################################################################
# Given a number of seconds, returns a string of format: H:MM:SS
###############################################################################

sub human_readable_time
{
  my $seconds = shift;
  my $minutes = ($seconds/60) % 60;
  my $hours   = ($seconds/3600);
  $seconds    =  $seconds % 60;

  return sprintf("%d:%02d:%02d", $hours, $minutes, $seconds);
}

###############################################################################
# Calculate the time remaining for a given download rate and chunk data.
###############################################################################

sub calculate_time_remaining
{
  my $downloaded_chunks = shift;
  my $total_chunks      = shift;
  my $chunk_size        = shift;
  my $download_rate     = shift;

  if ( $downloaded_chunks && $total_chunks && $chunk_size && $download_rate &&
       $downloaded_chunks != $total_chunks &&
       $download_rate > 0 ) {
    return human_readable_time((($total_chunks - $downloaded_chunks) * $chunk_size) / $download_rate);
  }
  else
  {
    return "-";
  }
}

###############################################################################
# The front page
###############################################################################

sub index_page
{
  return with_output_to_string {
    print h2({-id => 'title'},
             'CTorrent Control Server' .
             span({style=>'font-size: 250%; font-style: italic; position: relative; z-index: -1; top: 0.2em; right: 0.75em; color: #bfb;'},
                  '2'));
    my ($download_bandwidth, $upload_bandwidth) = total_used_bandwidth();
    my $current_download_field = human_readable($download_bandwidth);
    my $current_upload_field = human_readable($upload_bandwidth);
    my $download_field = textfield({name=> 'dlimit',
                                    value => ($ctcs{download_limit} / 1024),
                                    maxlength => 6,
                                    size => 6});
    my $upload_field = textfield({name=> 'ulimit',
                                  value=> ($ctcs{upload_limit} / 1024),
                                  maxlength => 6,
                                  size => 6});
    my $submit_button = submit({name=>'submit-bandwidth-changes',
                                value=>'Apply Changes'});

    printf '<form method="post" action="/" enctype="%s">', FORM_ENCODING;
    print div({id => 'global-bandwidth-limits'},
              table(
                    Tr(th('Current Download Bandwidth:'),
                       td({id => 'download-bandwidth'},
                          $current_download_field . '/s')),
                    Tr(th('Current Upload Bandwidth:'),
                       td({id => 'upload-bandwidth'},
                          $current_upload_field . '/s')),
                    Tr(th('Global Download Limit:'),
                       td($download_field, ' KB/s')),
                    Tr(th('Global Upload Limit:'),
                       td($upload_field, ' KB/s')),
                    Tr(th('Auto-Refresh:'),
                       td(checkbox(-name    => 'auto-refresh',
                                   -label   => '',
                                   -value   => '1',
                                   -id      => 'auto-refresh',
                                   -checked => $ctcs{auto_refresh}))),
                    Tr(td(a({href  => '/advanced-limits',
                             title => 'Fine-grained control over bandwidth limits'},
                            'Advanced Limits')),
                       td({align => 'right'},
                          $submit_button))));
    print end_form();

    print CGI::start_table({id => 'torrents'});
    print Tr(th('Name'), th('% Complete'), th('Time Remaining'), th('Download Rate'), th('Upload Rate'),
             th('Seeds'), th('Leeches'), th('Downloaded'), th('Uploaded'),
             th('Size'), th('Ratio'), th('Action'));

    my @torrent_info = sort {
      ($b->{percent_complete} || 0) <=> ($a->{percent_complete} || 0)
    } map { torrent_handled_by($_) } torrent_clients();

    for (my $count = 0; $count < @torrent_info; $count++)
    {
      my $torrent          = $torrent_info[$count];
      my $torrent_id       = CGI::escape($torrent->{ctcs_id});
      my $torrent_link     = a({href=> "/torrent/" . CGI::escape($torrent->{ctcs_id})}, $torrent->{name});
      my $upload_rate      = human_readable($torrent->{upload_rate});
      my $download_rate    = human_readable($torrent->{download_rate});
      my $total_seeders    = $torrent->{total_seeders};
      my $active_seeders   = $torrent->{active_seeders};
      my $total_leechers   = $torrent->{total_leechers};
      my $active_leechers  = $torrent->{active_leechers};
      my $downloaded       = human_readable($torrent->{downloaded}, '0.2f');
      my $uploaded         = human_readable($torrent->{uploaded}, '0.2f');
      my $size             = human_readable($torrent->{size}, 'd', '0.2f');
      my $percent_complete = sprintf('%d%%', $torrent->{percent_complete});
      my $smoothed_dl_rate = 0;

      $smoothed_dl_rate += $_ for @{$torrent->{download_rate_history}};
      $smoothed_dl_rate = $smoothed_dl_rate/$#{$torrent->{download_rate_history}} if $smoothed_dl_rate > 0;

      my $time_to_finish   = calculate_time_remaining($torrent->{downloaded_chunks},
                                                      $torrent->{total_chunks},
                                                      $torrent->{piece_size},
                                                      $smoothed_dl_rate);
      my $raw_ratio        = ($torrent->{uploaded} == 0) ? 0 :
      ($torrent->{downloaded} == 0) ? 'Inf.' :
      $torrent->{uploaded} / $torrent->{downloaded};
      my $ratio            = formatted_ratio_for($torrent);
      my $row_class        = ($count % 2 == 0) ? 'torrent-even' : 'torrent-odd';
      $row_class .= ' complete' if $torrent->{percent_complete} == 100;
      my $red              = ($ratio eq 'Inf.') ? 0 : int((1 - $ratio) * 255);
      my $green            = ($ratio eq 'Inf.') ? 255 : int($ratio * 128);

      $red   = 0 if $red < 0;
      $green = 255 if $ratio eq 'Inf.' || $ratio > 255;

      my $row_colour       = sprintf('#%06x', ($red << 16 | $green << 8 | 0));
      my $pause_unpause = $torrent->{config}->{pause}->{value} == 1 ? "Resume" : "Pause";

      $torrent->{config}->{pause}->{value} == 1 && ($row_class .= ' paused');
      print Tr({class => $row_class,
                id    => $torrent_id},
               td({class => 'title'}, $torrent_link),
               td({id => "percent_complete-$torrent_id"}, $percent_complete),
               td({id => "time_remaining-$torrent_id"}, $time_to_finish),
               td({id => "download_rate-$torrent_id"}, $download_rate . '/s'),
               td({id => "upload_rate-$torrent_id"}, $upload_rate . '/s'),
               td({id => "seeders-$torrent_id"}, $active_seeders, '/', $total_seeders),
               td({id => "leechers-$torrent_id"}, $active_leechers, '/', $total_leechers),
               td({id => "downloaded-$torrent_id"}, $downloaded),
               td({id => "uploaded-$torrent_id"}, $uploaded),
               td({id => "size-$torrent_id"}, $size),
               td({style => "color: $row_colour", id => "ratio-$torrent_id"}, $ratio),
               td(sprintf('<form name="%s" method="post" action="/status-action" enctype="%s">',
                          $torrent_id,
                          FORM_ENCODING),
                  Select({name         => 'action'},
                         option({value => $pause_unpause,
                                 id    => "pause_unpause-$torrent_id"},
                                $pause_unpause),
                         option({value => 'Update'}, 'Update'),
                         option({value => 'Quit'}, 'Quit')),
                  submit(-name         => 'submit', -value => 'Ok'),
                  hidden(-name         => 'torrent-id', -value => $torrent_id),
                  end_form()));
    }
    print CGI::end_table();
    print q(<script type="text/javascript">setTimeout('update_with_current_status()', 5000);</script>);
  };
}

sub formatted_ratio_for
{
  my $torrent = shift;
  my $raw_ratio        = ($torrent->{uploaded} == 0) ? 0 :
  ($torrent->{downloaded} == 0) ? 'Inf.' :
  $torrent->{uploaded} / $torrent->{downloaded};
  return ($raw_ratio eq 'Inf.') ? 'Inf.' : sprintf("%.02f", $raw_ratio);
}

###############################################################################
# The stats/info page for a given torrent
###############################################################################

sub torrent_info_page
{
  my $encoded_id     = shift;
  my $decoded_id     = CGI::unescape($encoded_id);
  my $torrent_info   = get_torrent_by_id($decoded_id);

  return undef if !defined($torrent_info);

  my $torrent_name   = $torrent_info->{name};
  my @peers          = sort { $b->{pieces} <=> $a->{pieces} } @{$torrent_info->{peers}};
  my %config         = %{$torrent_info->{config}};
  my @files          = @{$torrent_info->{files}};
  my @config_options = sort keys %config;
  return with_output_to_string {
    print h2({id => 'title'}, $torrent_name);
    print a({style=>'float: right;', href=>'/'}, 'Home');
    print h3('Peers');
    print ctcs_peers_table($torrent_info);
    print h3('Config');
    print ctcs_config_table($torrent_info);
    print h3('Files');
    print ctcs_file_table($torrent_info);
    print a({style=>'float: right;', href=>'/'}, 'Home');
  };
}

sub advanced_limits_page
{
  return with_output_to_string {
    my @clients = torrent_clients();
    print h2({id => 'title'}, 'Advanced Bandwidth Limits');
    print h3({style => 'text-align: center' },
             sprintf("Global Upload Limit: %s/s; Global Download Limit: %s/s",
                     human_readable($ctcs{upload_limit}),
                     human_readable($ctcs{download_limit})));
    printf '<form action="/set-advanced-limits" method="post" enctype="%s">', FORM_ENCODING;
    print CGI::start_table({id => 'torrents'});
    print Tr(th('Torrent'), th('Upload Limit (KB/s)'), th('Download Limit (KB/s)'), th('Auto-Manage'));

    for (my $count = 0; $count < scalar @clients; $count++)
    {
      my $client = $clients[$count];
      my $torrent = torrent_handled_by($client);
      my $upload_limit = int(($torrent->{manual_upload_limit} || $torrent->{upload_limit} || 0) / 1024);
      my $download_limit = int(($torrent->{manual_download_limit} || $torrent->{download_limit} || 0) / 1024);
      my $id = CGI::escape($torrent->{ctcs_id});
      my $upload_limit_widget = textfield(-name => "upload-$id",
                                          -size => 6,
                                          -value => $upload_limit);
      my $download_limit_widget = textfield(-name => "download-$id",
                                            -size => 6,
                                            -value => $download_limit);
      my $auto_manage_widget = checkbox(-name => "automanage-$id",
                                        -label => '',
                                        -value => 1,
                                        -title => 'Tick to have ctorrent automatically manage bandwidth for this torrent',
                                        -checked =>
                                        !exists($torrent->{manual_download_limit}) &&
                                        !exists($torrent->{manual_upload_limit})
                                       );
      print Tr({class => ($count % 2) == 0 ? 'torrent-even' : 'torrent-odd'},
               td({class => 'title'}, $torrent->{name}),
               td($upload_limit_widget),
               td($download_limit_widget),
               td($auto_manage_widget)
              );
    }
    print Tr(td(a({href => '/', title => 'Go to front page'}, 'Home')),
             td({colspan => '2', align => 'right'}, submit(-value => 'Apply Changes')));
    print CGI::end_table();
    print end_form();
  }
}

sub ctcs_file_table
{
  my $torrent_info = shift;
  my @files        = @{$torrent_info->{files}};

  return with_output_to_string {
    print CGI::start_table({id => 'files'});
    print Tr(th('File'), th('Size'), th('% Complete'));

    for (my $count = 1; $count < scalar @files; $count++)
    {
      my $file = $files[$count];
      print Tr({class => ($count % 2 == 1) ? 'file-even' : 'file-odd'},
               td({class => 'title'}, $count, ': ', $file->{name}),
               td({align => 'right'}, human_readable($file->{size}, 'd', '.02f')),
               td({align => 'right'}, int($file->{percent_done}), '%'));
    }
    print CGI::end_table();
  }
}

sub ctcs_config_table
{
  my $torrent_info   = shift;
  my %config         = %{$torrent_info->{config}};
  my @config_options = sort keys %config;
  return with_output_to_string {
    printf '<form method="post" action="/set-config" enctype="%s">', FORM_ENCODING;
    print CGI::start_table({id => 'config'});
    print Tr(th('Option'), th({colspan => 2}, 'Value'));

    for (my $count = 0; $count < scalar @config_options; $count++)
    {
      print Tr({class => ($count % 2 == 0) ? 'peer-even' : 'peer-odd'},
               td($config{$config_options[$count]}->{short_desc}),
               td(ctcs_config_table_widget($config_options[$count],
					   $config{$config_options[$count]})),
               td($config{$config_options[$count]}->{long_desc}));
    }
    print Tr(td(), td(submit(-value => 'Apply Changes')), td());
    print CGI::end_table();
    print hidden(-name => 'torrent-id', -value => CGI::escape($torrent_info->{ctcs_id}));
    print end_form();
  }
}

sub ctcs_config_table_widget
{
  my ($field, $option) = @_;
  if ($option->{type} eq 'B')
  {
    return checkbox(-name    => $field,
                    -value   => '1',
                    -label   => '',
                    -checked => $option->{value} eq '1');
  }
  else
  {
    return textfield(-name  => $field,
                     -size  => 12,
                     -value => $option->{value});
  }
}

sub ctcs_peers_table
{
  my $torrent_info = shift;
  my @peers        = sort { $b->{pieces} <=> $a->{pieces} } @{$torrent_info->{peers}};

  return with_output_to_string {
    print CGI::start_table({id => 'peers', width => '100%'});
    print Tr(th(), th('Address'), th('Chunks (of ', $torrent_info->{total_chunks}, ')'),
             th('Uploaded (from you)'), th('Upload Rate'),
             th('Downloaded (to you)'), th('Download Rate'));
    for (my $count = 0; $count < scalar @peers; $count++)
    {
      my $peer      = $peers[$count];
      print Tr({class => ($count % 2 == 0) ? 'peer-even' : 'peer-odd'},
               td({class => ($peer->{pieces} == $torrent_info->{total_chunks}) ? 'seed' : 'leech'}),
               td($peer->{address}),
               td($peer->{pieces},
                  sprintf('(%d%%)', int(($peer->{pieces} / $torrent_info->{total_chunks}) * 100))),
               td(human_readable($peer->{uploaded})),
               td(human_readable($peer->{upload_rate})),
               td(human_readable($peer->{downloaded})),
               td(human_readable($peer->{download_rate})));
    }
    print CGI::end_table();
  };
}

###############################################################################
# A handy page dumping the internals of what's going on
###############################################################################

sub debug_page
{
  return with_output_to_string {
    print h1('Debug');
    print CGI::start_pre();
    print handle_dump();
    print CGI::end_pre();
  };
}

###############################################################################
# The page you get when no other page matched up to your request
###############################################################################

sub error_page
{
  my $page = shift;
  return with_output_to_string {
    print h1('Whoops!');
    print p("The page you're looking for, $page, doesn't exist!");
    print a({href=>'/'}, 'Go Home');
  };
}

###############################################################################
# Dumps out a list of currently registered sockets.  This is useful for
# debugging
###############################################################################

sub handle_dump
{
  return with_output_to_string {
    print "CTCS\n\n";
    while (my ($key, $value) = each %ctcs)
    {
      printf "%s: %s\n", $key, $value;
    }
    print "\nREADERS\n\n";
    map { printf "%s: %s:%d (%s)\n",
          $_,
          $_ == $server ? "SERVER" : address_of($_),
          $_ == $server ? $ctcs{port} : $_->peerport(),
          $_ == $server ? "SERVER" : exists($clients{$_}->{torrent}) ? "TORRENT: " . $clients{$_}->{torrent}->{name} : "WEB"
        } $readers->handles;
    print "\nWRITERS\n\n";
    map { printf "%s: %s:%d (%s)\n",
          $_,
          $_ == $server ? "SERVER" : address_of($_),
          $_ == $server ? $ctcs{port} : $_->peerport(),
          $_ == $server ? "SERVER" : exists($clients{$_}->{torrent}) ? "TORRENT: " . $clients{$_}->{torrent}->{name} : "WEB"
        } $writers->handles;
    print "\nMESSAGES\n\n";
    print Dumper(\%clients);
  };
}

###############################################################################
# Note download/upload figures for a particular client.
###############################################################################

sub record_bandwidth
{
  my ($client, $dlrate, $ulrate) = @_;
  my $info = torrent_handled_by($client);
  $info->{upload_rate}   = $ulrate;
  $info->{download_rate} = $dlrate;

  my $dl_hist= $info->{download_rate_history};
  push(@{$dl_hist}, $dlrate);
  shift @{$dl_hist} if $#{$dl_hist} > 100;

  my $smoothed_dl_rate= 0;
  my $dl_count= $#{$dl_hist};

  $smoothed_dl_rate += $_ for @{$dl_hist};

  $info->{smoothed_dl_rate} = $dl_count == 0 ? 0 : $smoothed_dl_rate/$dl_count;

  my $total = exists($info->{total_chunks}) ? $info->{total_chunks} : 0;
  my $downloaded = exists($info->{downloaded_chunks}) ? $info->{downloaded_chunks} : 0;
  $info->{percent_complete} = $total == 0 ?
  0 : int(($downloaded / $total) * 100);
}

###############################################################################
# Handles internal registration of the given torrent.  Until explicitly
# de-registered, this torrent will remain on this server's list for the
# server lifetime.
###############################################################################

sub handle_register_torrent
{
  my ($socket, $torrent_id, $start_time, $current_time, $torrent_name) = @_;

  my $info = {};
  $info->{name}                  = $torrent_name;
  $info->{ctorrent_id}           = $torrent_id;
  $info->{ctcs_id}               = 'ctcs-torrent-' . ++$current_id;
  $info->{config}                = { pause => {value => 0}};
  $info->{percent_complete}      = 0;
  $info->{files}                 = [];
  $info->{peers}                 = [];
  $info->{active_seeders}        = 0;
  $info->{total_seeders}         = 0;
  $info->{active_leechers}       = 0;
  $info->{total_leechers}        = 0;
  $info->{total_connections}     = 0;
  $info->{downloaded_chunks}     = 0;
  $info->{total_chunks}          = 0;
  $info->{available_chunks}      = 0;
  $info->{download_rate}         = 0;
  $info->{download_rate_history} = [];
  $info->{smoothed_dl_rate}      = 0;
  $info->{upload_rate}           = 0;
  $info->{downloaded}            = 0;
  $info->{uploaded}              = 0;
  $info->{download_limit}        = 0;
  $info->{upload_limit}          = 0;
  $info->{cache_used}            = 0;
  $info->{last_detail_update}    = 0;
  $info->{size}                  = 0;

  $clients{$socket}->{torrent} = $info;

}

###############################################################################
# Defines a function that reads lines from an I/O handle given to it.  Can,
# if given a second 'limit' parameter, instead be used to read a specific
# number of bytes.
#
# * If the line is successfully read, this method returns the completed line.
# * If a full line cannot be read (but *something* is) this method returns
#   undef, and $! is EAGAIN.  The partially read string is stored for
#   a later read.
# * If nothing can be read, and the underlying read hasn't set $!, this
#   method returns undef: check $! to determine what has happened.
###############################################################################

sub line_reader_function
{
  my ($buffer, $buffer_length) = ('', 0);

  return sub {

    my $client          = shift; # Mandatory
    my $bytes_requested = shift; # Optional

    ###########################################################################
    # Figure out how much has to be retrieved from sysread, rather than using
    # the internal buffer.  In the case of reading lines, this could well be
    # zero, if the buffered data already has a complete line in it.
    ###########################################################################

    my $external_read_size =
    (defined($bytes_requested) && $bytes_requested >= $buffer_length) ?
    $bytes_requested - $buffer_length :
    ($buffer               =~ /\n/) ? 0 :
    1024;

    ###########################################################################
    # Read from the exteral source, if required
    ###########################################################################

    if ($external_read_size > 0)
    {
      my $result = sysread($client, $buffer, $external_read_size, $buffer_length);
      return undef if !defined($result) || $result == 0;
      $buffer_length += $result;
    }

    ###########################################################################
    # $bytes_requested, if defined, indicates the minimum that the caller
    # wanted: don't give back anything if the entire request can't be
    # satisfied.
    # Without $bytes_requested, the absence of a newline in the buffer means
    # that a complete line can't be returned: return undef instead.
    ###########################################################################

    return undef if defined($bytes_requested) && $bytes_requested < $buffer_length;
    return undef unless defined($bytes_requested) || $buffer =~ /\n/g;

    ###########################################################################
    # Ok, by now, $buffer has enough data in it, so extract the line/required
    # number of bytes and adjust the internal buffer appropriately.
    ###########################################################################

    my $snip_point   = $bytes_requested || pos($buffer);
    my $line         = substr($buffer, 0, $snip_point);
    $buffer          = $snip_point < $buffer_length ? substr($buffer, $snip_point) : '';
    $buffer_length  -= length($line);

    ###########################################################################
    # Unless extracting a specific number of bytes, trim off any blank spaces
    # at the end of the line
    ###########################################################################

    $line =~ s/(^|\S)\s*$/$1/ unless defined($bytes_requested);
    return $line;
  };
}

###############################################################################
# A simple logger.
###############################################################################

sub ctcs_log
{
  return if $_[0] < $ctcs{log_level} && $_[0] != LOG_TEMP;
  my ($level, $format) = (shift, shift);
  my $log = $ctcs{log_file_handle} || \*STDOUT;
  if ($ctcs{log_timestamps})
  {
    print $log strftime("%H:%M:%S, %a, %b %d %Y", localtime()), ": ";
  }
  printf $log $format, @_;
  print $log "\n";
}

###############################################################################
# Given a socket, returns a hash reference with keys representing information
# about a torrent file (the most important usually being 'name')
###############################################################################

sub torrent_handled_by
{
  my $client = shift;
  return $clients{$client}->{torrent};
}

###############################################################################
# Return all torrent instances currently registered with this server
###############################################################################

sub all_torrents
{
  map { $clients{$_}->{torrent} } grep { exists($clients{$_}->{torrent}) } keys %clients;
}

###############################################################################
# Returns a list of sockets that are supplying torrent data (as opposed to
# connections from the Web interface
###############################################################################

sub torrent_clients
{
  my @torrent_clients = ();
  foreach my $client (keys %clients)
  {
    push(@torrent_clients, $clients{$client}->{socket}) if exists($clients{$client}->{torrent});
  }
  return @torrent_clients;
}

###############################################################################
# Figures out what the average bandwidth for each register torrent should be
# given the global download and upload limits.
###############################################################################

sub autobalance_bandwidth
{
  my @torrent_clients  = torrent_clients();
  my $client_count     = scalar(@torrent_clients) || 1;
  my $uploader_count   = 0;
  my $downloader_count = 0;

  foreach my $client (@torrent_clients)
  {
    my $torrent  = torrent_handled_by($client);
    my $complete = $torrent->{percent_complete} eq '100';
    my $paused   = $torrent->{config}->{pause}->{value} eq '1';
    $uploader_count++ unless $paused;
    $downloader_count++ unless ($paused || $complete);
  }

  $uploader_count   ||= 1;
  $downloader_count ||= 1;

  foreach my $client (@torrent_clients)
  {
    my $torrent  = torrent_handled_by($client);
    my $paused   = $torrent->{config}->{pause}->{value} == 1;
    my $complete = $torrent->{percent_complete} == 100;

    my $upload_limit   = $paused ? 0 :
    (exists($torrent->{manual_upload_limit})) ?
    $torrent->{manual_upload_limit}  :
    int($ctcs{upload_limit} / $uploader_count);

    my $download_limit = ($paused || $complete) ? 0 :
    (exists($torrent->{manual_download_limit})) ?
    $torrent->{manual_download_limit} :
    int($ctcs{download_limit} / $downloader_count);

    if ($upload_limit != $torrent->{upload_limit})
    {
      torrent_set_bandwidth_limit($torrent, 'upload', $upload_limit);
    }
    if ($download_limit != $torrent->{download_limit})
    {
      torrent_set_bandwidth_limit($torrent, 'download', $download_limit);
    }
  }
}

###############################################################################
# Sends the given string as a message to the given client.  This doesn't
# happen immediately: the message is queued for sending with the next
# write loop.
###############################################################################

sub send_message
{
  my ($message, $client) = @_;
  send_message_function(writer_function(sub { $message }), $client);
}

###############################################################################
# Sends a message preceded by appropriate HTTP headers.  An optional third
# argument can be a hash with specific HTTP headers to set.  Unless overridden,
# the default content type is text/plain.  Do NOT specify a 'Content-Length':
# it will be generated automatically.  The Content Type should be overridden
# with the 'Content-Type' key.
###############################################################################

sub send_http_message
{
  my ($message, $client, %headers) = @_;
  my $http_message = IO::String->new();

  $headers{'Content-Type'} ||= 'text/plain';

  print $http_message 'HTTP/1.1 200 OK', $CRLF;
  map { print $http_message $_, ': ', $headers{$_}, $CRLF } keys %headers;
  print $http_message 'Content-Length: ', length($message), $CRLF, $CRLF;
  print $http_message $message;

  send_message( ${$http_message->string_ref()}, $client);
}

###############################################################################
# Adds the given writer function to the message queue of the given client.
# As with send_message, the send doesn't happen immediately.
###############################################################################

sub send_message_function
{
  my ($function, $client) = @_;
  push (@{$clients{$client}->{messages}}, $function);
  $writers->add($client) unless $writers->exists($client);
}

###############################################################################
# For a given id, find the torrent subhash in %clients that contains the
# information about that torrent.  Return undef if no such torrent is found
###############################################################################

sub get_torrent_by_id
{
  my $id = shift;

  foreach my $client (keys %clients)
  {
    if (exists($clients{$client}->{torrent}) &&
        $clients{$client}->{torrent}->{ctcs_id} eq $id) {
      return $clients{$client}->{torrent};
    }
  }
  return undef;
}

sub get_client_by_id
{
  my $id = shift;

  foreach my $client (keys %clients)
  {
    if (exists($clients{$client}->{torrent}) &&
        $clients{$client}->{torrent}->{ctcs_id} eq $id) {
      return $clients{$client}->{socket};
    }
  }
  return undef;
}

###############################################################################
# Returns a two element list containing the total download and upload bandwidth
# figures for torrents registered with this server.
###############################################################################

sub total_used_bandwidth
{
  my $total_upload = 0;
  my $total_download = 0;
  foreach my $client (torrent_clients())
  {
    $total_upload   += ($clients{$client}->{torrent}->{upload_rate} || 0);
    $total_download += ($clients{$client}->{torrent}->{download_rate} || 0);
  }
  return ($total_download, $total_upload);
}

###############################################################################
# Which protocol version?
# (kinda redundant as I don't pay attention to it anywhere yet.
###############################################################################

sub ctcs_protocol
{
  return $ctcs{protocol};
}

###############################################################################
# The command that should be sent to get more detail
###############################################################################

sub ctcs_request_detail_command
{
  return "SENDDETAIL\r\n";
}

sub ctcs_request_status_command
{
  return "SENDSTATUS\r\n";
}

sub ctcs_request_config_command
{
  return "SENDCONF\r\n";
}

sub ctcs_request_peers_command
{
  return "SENDPEERS\r\n";
}

###############################################################################
# Given the torrent info subhash and the detail string returned by
# an incoming CTFILE, populates the torrent hash with the details
# After this is complete, $torrent_info{files} is a list reference, indexed
# by file number (in the torrent), and where each element is a hash reference
# containing the 'size' and 'name' keys.
###############################################################################

sub torrent_populate_file_info
{
  my ($torrent_info, $detail_string) = @_;
  my ($fnum, $fpri, $curpri, $fnp, $fnh, $fna, $fsize, $fname) =
  split(/\s+/, $detail_string, 8);
  $torrent_info->{files} ||= [];
  $torrent_info->{files}->[$fnum] ||= {};
  $torrent_info->{files}->[$fnum]->{size} = $fsize;
  $torrent_info->{files}->[$fnum]->{name} = $fname;
  $torrent_info->{files}->[$fnum]->{percent_done} = $fnp ? 100 * $fnh / $fnp : 0;
}

sub torrent_update_detail
{
  torrent_update_only_after_minimum_time(shift,
                                         'last_detail_update',
                                         5,
                                         \&torrent_request_detail_from);
}

sub torrent_update_status
{
  torrent_update_only_after_minimum_time(shift,
                                         'last_status_update',
                                         10,
                                         \&torrent_request_status_from);
}

sub torrent_update_config
{
  torrent_update_only_after_minimum_time(shift,
                                         'last_config_update',
                                         10,
                                         \&torrent_request_config_from);
}

sub torrent_update_peers
{
  my ($client) = @_;
  return if exists(torrent_handled_by($client)->{incoming_peers});
  torrent_update_only_after_minimum_time(shift,
                                         'last_peers_update',
                                         30,
                                         \&torrent_request_peers_from);
}

sub ctcs_update_bandwidth_allocation
{
  ctcs_update_only_after_minimum_time('last_bandwidth_update',
                                      10,
                                      \&autobalance_bandwidth);
}

sub torrent_update_only_after_minimum_time
{
  my ($client, $field, $interval, $request_function) = @_;
  my $torrent_info = torrent_handled_by($client);
  my $time = time();
  if (!exists($torrent_info->{$field}) ||
      ($time - $torrent_info->{$field} > $interval)) {
    $request_function->($client);
    $torrent_info->{$field} = $time;
  }
}

sub ctcs_update_only_after_minimum_time
{
  my ($field, $interval, $function, @args) = @_;
  my $time = time();
  if (!exists($ctcs{$field}) || ($time - $ctcs{$field} > $interval))
  {
    $function->(@args);
    $ctcs{$field} = $time;
  }
}

sub torrent_set_status
{
  my ($torrent_info, $status_line) = @_;

  # Apologies for the horrendous pattern match.
  $1 =~ m!^
          (\d+):(\d+)/       # Active seeds, and total seeders
          (\d+):(\d+)/       # Active leechers, and total leechers
          (\d+)              # Total connections
          \s+
          (\d+)/(\d+)/(\d+)  # Chunks downloaded, total, and available
          \s+
          (\d+),(\d+)        # Download/upload rates
          \s+
          (\d+),(\d+)        # Total downloaded/uploaded
          \s+
          (\d+),(\d+)        # Download/upload limits
          \s+
          (\d+)              # Cache used
         !x;

  $torrent_info->{active_seeders}     = $1;
  $torrent_info->{total_seeders}      = $2;
  $torrent_info->{active_leechers}    = $3;
  $torrent_info->{total_leechers}     = $4;
  $torrent_info->{total_connections}  = $5;
  $torrent_info->{downloaded_chunks}  = $6;
  $torrent_info->{total_chunks}       = $7;
  $torrent_info->{available_chunks}   = $8;
  $torrent_info->{download_rate}      = $9;
  $torrent_info->{upload_rate}        = $10;
  $torrent_info->{downloaded}         = $11;
  $torrent_info->{uploaded}           = $12;
  $torrent_info->{download_limit}     = $13;
  $torrent_info->{upload_limit}       = $14;
  $torrent_info->{cache_used}         = $15;
  $torrent_info->{last_detail_update} = time();
}

################################################################################
# Asynchronously sends a SENDDETAIL request to the given client.
###############################################################################

sub torrent_request_status_from
{
  send_message(ctcs_request_status_command(), shift);
}

sub torrent_request_detail_from
{
  send_message(ctcs_request_detail_command(), shift);
}

sub torrent_request_peers_from
{
  send_message(ctcs_request_peers_command(), shift);
}

sub torrent_request_config_from
{
  send_message(ctcs_request_config_command(), shift);
}

sub torrent_store_config
{
  my ($torrent, $config_line) = @_;
  if ($config_line =~ /(\S+)      # element name
                       \s+
                       (\S+)      # element type
                       \s+
                       (\S+)      # element range
                       \s+
                       (\d+):     # element length
                      /gx) {
    my ($short_description, $long_description);
    my ($element, $type, $range, $value_length) = ($1, $2, $3, $4);
    my $value = substr($config_line, pos($config_line), $value_length);
    my $length = $1 if $config_line =~ /\s*(\d+):/g;
    if ($length)
    {
      $short_description = substr($config_line, pos($config_line), $length);
    }
    $length = $1 if $config_line =~ /(\d+):/g;
    if ($length)
    {
      $long_description = substr($config_line, pos($config_line), $length);
    }
    $torrent->{config}->{$element} = {short_desc => ($short_description || ''),
                                      long_desc  => ($long_description || ''),
                                      type       => $type,
                                      range      => $range,
                                      value      => $value};
  }
}

sub torrent_add_peer
{
  my ($torrent_info, $peer_description) = @_;
  if ($peer_description =~ /
                             ([^\s]+)    # Peer id
                             \s+
                             ([\d.:]+)   # IP address
                             \s+
                             ([CU][in])([CU][in]) # Choked-interested
                             \s+
                             (\d+)       # Download rate
                             \s+
                             (\d+)       # Upload rate
                             \s+
                             (\d+)       # Downloaded
                             \s+
                             (\d+)       # Uploaded
                             \s+
                             (\d+)       # pieces
                           /x) {
    push(@{$torrent_info->{incoming_peers} ||= []},
         {id            => $1,
          address       => $2,
          remote_flags  => $3,
          local_flags   => $4,
          download_rate => $5,
          upload_rate   => $6,
          downloaded    => $7,
          uploaded      => $8,
          pieces        => $9});
  }
}

sub torrent_set_manual_bandwidth_limit
{
  my ($torrent, $direction, $limit) = @_;
  $torrent->{"manual_${direction}_limit"} = $limit;
  torrent_set_bandwidth_limit($torrent, $direction, $limit);
}

sub torrent_set_bandwidth_limit
{
  my ($torrent, $direction, $limit) = @_;
  my $message = ($direction eq 'upload') ? 'U' : 'D';
  my $client = get_client_by_id($torrent->{ctcs_id});
  if ($direction eq 'upload')
  {
    $torrent->{upload_limit} = $limit;
  }
  elsif ($direction eq 'download')
  {
    $torrent->{download_limit} = $limit;
  }
  else
  {
    ctcs_log(LOG_WARNING,
             "Cannot set bandwidth for unknown direction '$direction'");
    return;
  }
  ctcs_log(LOG_INFO,
           "Setting %s limit of '%s' to %d",
           $direction,
           $torrent->{name},
           $limit);
  send_message(sprintf("SET${message}LIMIT %.0f\r\n", $limit), $client);
}

sub torrent_quit
{
  send_message("CTQUIT\r\n", get_client_by_id((shift)->{ctcs_id}));
}

sub torrent_update
{
  send_message("CTUPDATE\r\n", get_client_by_id((shift)->{ctcs_id}));
}

sub torrent_pause
{
  torrent_set_config(shift, 'pause', 1);
}

sub torrent_is_paused
{
  my ($torrent) = @_;
  return $torrent->{config}->{pause}->{value} == 1;
}

sub torrent_resume
{
  torrent_set_config(shift, 'pause', 0);
}

sub torrent_set_config
{
  my ($torrent, $config_option, $value) = @_;
  my $client = get_client_by_id($torrent->{ctcs_id});
  if (!defined($client))
  {
    ctcs_log(LOG_WARNING,
             "Cannot set config on torrent '%s': it has no active connection",
             $torrent->{name});
    return;
  }
  else
  {
    ctcs_log(LOG_INFO,
             "Setting config option '%s' of '%s' to '%s'",
             $config_option, $torrent->{name}, $value);
  }
  send_message(sprintf("CTCONFIG %s %s\r\n", $config_option, $value), $client);
  torrent_request_config_from($client);
}

###############################################################################
# Given a number that is assumed to be a number of bytes, returns a string
# that truncates that number with a useful suffix (i.e. 'MB' or 'GB').
# If a format specifier is given, it is used the format the number.  If an
# additional 'small format' specifier is given, it is used instead of the
# normal specifier if the number is less than 10.
###############################################################################

sub human_readable
{
  my $number       = shift;
  my $format       = shift || 'd';
  my $small_format = shift || $format;

  return "" if !defined($number);
  $number          = $1 if $number =~ /(\d+)/;

  my @range   = ('B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB'); # Future proofing...
  my $current = 0;
  ($number /= 1024) && $current++ while $number > 1024;

  return $number < 10 ?
  sprintf("%$small_format %s", $number, $range[$current]) :
  sprintf("%$format %s", $number, $range[$current]);
}

###############################################################################
# A bit of profiling on FreeBSD showed that gethostbyaddr is quite expensive,
# and invoking it every time a message is received (for the debug log)
# actually ramped up CPU time to almost twice what it was versus this caching
# version
###############################################################################

sub address_of
{
  my $client = shift;
  unless (exists $clients{$client}->{address})
  {
    $clients{$client}->{address} =
    (gethostbyaddr($client->peeraddr(), AF_INET))[0];
  }
  return $clients{$client}->{address};
}

sub peer_count_for
{
  my $info = torrent_handled_by(shift);
  return scalar @{$info->{peers}}
}

sub javascript
{
  #############################################################################
  # Yes, my JavaScript is poor: a better scripter than I should refactor this
  # entire block of code at the earliest opportunity
  #############################################################################

  my $script=<<END_JS;
  var xmlHttp = null;

  function ajaxObject()
  {
    if (xmlHttp) return xmlHttp;
    try {
      // Firefox, Opera 8.0+, Safari
      xmlHttp=new XMLHttpRequest();
    }
    catch (e) {
      // Internet Explorer
      try {
        xmlHttp=new ActiveXObject("Msxml2.XMLHTTP");
      }
      catch (e) {
        try {
          xmlHttp=new ActiveXObject("Microsoft.XMLHTTP");
        }
        catch (e) {
          return false;
        }
      }
    }
    return xmlHttp;
  }

  function update_with_current_status()
  {
    var xmlHttp = ajaxObject();

    if(!xmlHttp) return;

    if (document.getElementById('auto-refresh').checked)
    {
      xmlHttp.onreadystatechange = function() {
        if (xmlHttp.readyState == 4 && xmlHttp.responseText) {
          data = eval('(' + xmlHttp.responseText + ')');
          document.getElementById('download-bandwidth').innerHTML = data["download"];
          document.getElementById('upload-bandwidth').innerHTML = data["upload"];
          var torrent_data = data["torrents"];
          for (var i = 0; i < torrent_data.length; i++)
          {
            var torrent = torrent_data[i];
            var row_id = torrent["id"];
            var row;

            // If the row's already there, update it.

            row = document.getElementById(row_id);
            if (row)
            {
              update_torrent_row(row, row_id, torrent);
            }
            else // the row's not there: create it.
            {
              add_new_torrent(torrent);
            }
          }
          cleanup_dead_torrents(torrent_data);
          sort_torrents_table();
        }
      };
      xmlHttp.open("GET", "/current-status")
      xmlHttp.send(null);
    }
    setTimeout('update_with_current_status()', 5000);
  }

  function update_torrent_row(row, row_id, torrent)
  {
    var completed = parseInt(torrent['percent_complete']) == 100;
    var ratio_element;
    var ratio_colour;
    var ratio;
    var green;
    var red;

    if (completed && row.className.search(/complete/) == -1)
    {
      row.className += ' complete';
    }
    document.getElementById('percent_complete-' + row_id).innerHTML = torrent["percent_complete"] + '%';
    document.getElementById('time_remaining-' + row_id).innerHTML = torrent["time_remaining"];
    document.getElementById('download_rate-' + row_id).innerHTML = torrent["download_rate"];
    document.getElementById('upload_rate-' + row_id).innerHTML = torrent["upload_rate"];
    document.getElementById('seeders-' + row_id).innerHTML = torrent["seeders"];
    document.getElementById('leechers-' + row_id).innerHTML = torrent["leechers"];
    document.getElementById('downloaded-' + row_id).innerHTML = torrent["downloaded"];
    document.getElementById('uploaded-' + row_id).innerHTML = torrent["uploaded"];
    document.getElementById('size-' + row_id).innerHTML = torrent["size"];
    ratio_element = document.getElementById('ratio-' + row_id)
    ratio_element.innerHTML = torrent["ratio"];
    if (torrent["paused"] == '1' && row.className.search(/paused/) == -1)
    {
      row.className = row.className + ' paused';
      var pause_option = document.getElementById('pause_unpause-' + row_id);
      pause_option.text = 'Resume';
      pause_option.value = 'Resume';
    }
    else if (torrent["paused"] == '' && row.className.search(/paused/) >= 0)
    {
      row.className = row.className.replace(/paused/, '');
      var pause_option = document.getElementById('pause_unpause-' + row_id);
      pause_option.text = 'Pause';
      pause_option.value = 'Pause';
    }
    if (torrent["ratio"] == "Inf.")
    {
      red = 0;
      green = 255;
    }
    else
    {
      ratio = parseFloat(torrent["ratio"]);
      red = 255 - (ratio * 255);  if (red < 0.0) red = 0.0;
      green = ratio * 128; if (green > 255) green = 255;
    }
    var colour = '' + ((red << 16) | (green << 8) | 0).toString(16);
    while(colour.length < 6) colour = '0' + colour;
    ratio_element.style.color = '#' + colour;
  }


  function add_new_torrent(torrent)
  {
    var torrents_table = document.getElementById('torrents');
    var cell_count = torrent.length + 1; // the +1 is for the action form at the end.
    var new_row = torrents_table.insertRow(torrents_table.rows.length);
    var completed = parseInt(torrent["percent_complete"]) == 100;

    new_row.id = torrent["id"];
    new_row.className = (torrents_table.rows.length % 2 == 0) ? 'torrent-even' : 'torrent-odd';
    if (completed) new_row.className += ' complete';

    torrent_link = document.createElement('a');
    torrent_link.href = '/torrent/' + escape(torrent["id"]);
    torrent_link.innerHTML = torrent["name"];

    var title_cell = new_row.insertCell(0);
    title_cell.className = 'title';
    title_cell.appendChild(torrent_link);

    var fields = ["percent_complete", "time_remaining", "download_rate", "upload_rate",
                  "seeders", "leechers", "downloaded", "uploaded", "size", "ratio"];
    var torrent_id = torrent["id"];

    for (var i = 0; i < fields.length; i++)
    {
      var cell = new_row.insertCell(i + 1);
      cell.id = fields[i] + "-" + torrent_id;
      cell.innerHTML = torrent[fields[i]];
      if (fields[i] == "percent_complete") cell.innerHTML += '%';
    }

    var action_form = document.createElement('form');
    action_form.method = "post";
    action_form.action = "/status-action";
    action_form.encoding = 'application/x-www-form-urlencoded';

    var action_select = document.createElement('select');
    action_select.name = 'action';

    var pause_unpause = (torrent["paused"] == 1) ? "Resume" : "Pause";
    var options = [ pause_unpause, "Update", "Quit"];

    for (var i = 0; i < options.length; i++)
    {
      var option = document.createElement('option');
      option.text = options[i];
      option.value = options[i];
      if (options[i] == 'Pause' || options[i] == 'Resume') option.id = 'pause_unpause-' + torrent_id;
      action_select.add(option, null);
    }

    var submit_button = document.createElement('input');
    submit_button.type = 'submit';
    submit_button.value = 'Ok';
    submit_button.name = 'submit';

    var hidden  = document.createElement('input');
    hidden.type = 'hidden';
    hidden.name = 'torrent-id';
    hidden.value = torrent["id"];

    action_form.appendChild(hidden);
    action_form.appendChild(action_select);
    action_form.appendChild(submit_button);

    var form_cell = new_row.insertCell(fields.length + 1);
    form_cell.appendChild(action_form);
  }

  function sort_torrents_table()
  {
    var table = document.getElementById('torrents');
    var rows = table.rows;
    var new_rows = new Array(rows.length - 1);
    for (var i = 0; i < new_rows.length; i++) new_rows[i] = rows.item(i + 1);
    new_rows.sort(function(a, b) {
      var first_percent = parseInt(a.cells[1].innerHTML);
      var second_percent = parseInt(b.cells[1].innerHTML);
      return second_percent - first_percent;
    });
    while(table.rows.length > 1) table.deleteRow(1);

    /* Now that I've gone and re-sorted everything, the row colours are most
       likely screwed, so they need re-adjusting */

    for (var i = 0; i < new_rows.length; i++)
    {
      var current_class = new_rows[i].className;
      var new_class = (i % 2 == 0) ? 'torrent-even' : 'torrent-odd';
      current_class = current_class.replace(/torrent-(even|odd)/, new_class);
      new_rows[i].className = current_class;
      table.appendChild(new_rows[i]);
    }
  }

  function cleanup_dead_torrents(torrent_data)
  {
    // Finally, go through the rows in the table and delete any that are not in the incoming data
    var table = document.getElementById('torrents');
    var index = 1; // Exclude the headings
    while(index < table.rows.length)
    {
      var id = table.rows[index].id;
      var found = 0;
      for (var i = 0; i < torrent_data.length; i++) if (torrent_data[i]["id"] == id) found = 1;
      if (found) index++;
      else table.deleteRow(index);
    }
  }
END_JS
}

###############################################################################
# The stylesheet that every page should use.
###############################################################################

sub stylesheet
{
  my $sheet = <<END_CSS;
body { font-family: Arial, sans-serif; margin-left: 5%; margin-right: 5%; margin-top: 0%; margin-bottom: 5%; }
#title { text-align: center; }
.torrent-even, .peer-even, .file-even { background-color: #ded; }
.torrent-odd, .peer-odd, .file-odd, div#global-bandwidth-limits { background-color: #efe; }
div#global-bandwidth-limits { width: 100%; padding-top: 1em; padding-bottom: 1em; }
div#global-bandwidth-limits table { margin-left: auto; margin-right: auto; }
div#global-bandwidth-limits table th { text-align: left; }
table#torrents { margin-top: 3em; }
table#torrents, table#files, table#peers, table#config {width: 100%; border-collapse: collapse; margin-left: auto; margin-right: auto; font-size: smaller; }
table#files { width: auto; }
.torrent-even, .peer-even, .file-even { border-width: 1px; border-style: solid; border-color: #cdc; border-top-color: #fff; }
.torrent-odd, .peer-odd, .file-odd { border-width: 1px; border-style: solid; border-color: #bcb; border-top-color: #efe; }
td { text-align: center; }
td.title { text-align: left; }
#upload-bandwidth, .excellent-ratio { color: #3b3; }
.good-ratio { color: #292; }
.ok-ratio { color: #992; }
#download-bandwidth, .poor-ratio { color: #a22; }
#upload-bandwidth, #download-bandwidth { font-weight: bold; }
td.seed, td.leech, .paused { filter:alpha(opacity=50); opacity: 0.5; -moz-opacity:0.5; }
td.seed { width: 1em; background-color: #3b3; }
td.leech { width: 1em; background-color: #a22; }
tr.complete, tr.complete a { font-weight: bold; color: green; }
END_CSS
}
__END__

BSD LICENCE

Copyright (c) 2009-2010 Danny Woods
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
3. The name of the author may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

HACKING GUIDE
-------------

aims
----

Externals

CTCS should remain a single file with Perl as its sole prerequisite.  This is
for ease of distribution.  At the time of this writing, Perl 5.8 is the
standard Perl on Linux, BSD, etc., so please limit language features and
modules to those available with a vanilla distribution of that version.

Internals

All state relating to a given client is in %clients, keyed by client socket.
The great advantage of this is that cleaning up all information related to a
given connection is a simple matter of grabbing hold of the socket, deleting
the %clients entry, and then closing the socket.  This greatly reduces the
chance of zombie connections.

Torrent info for an individual (torrent-supplying) client is in
$clients{a-client}->{torrent}.

All state pertaining to the server itself is in %ctcs.

Any new state added at a later date should be part of these two top-level
hashes (unless, of course, it clearly belongs to neither).

The code is single-threaded and uniprocess, and is simple, efficient and easy
to debug as a result.  Please resist the urge to change this.  Yes, periodic
updates of config information, peers, etc. would be nice in a separate thread
rather than in the top-level 'select' loop, but I would rather avoid the
headaches of synchronised access to the %clients hash.

Useful Bits
-----------

The '/debug' page on the web UI shows the current state of the core data
structures used by the program: it is extremely useful for data visualisation.

function_to_handle_request

This is the primary function for deciding how to deal with an incoming request.
For HTTP GETs and POSTs, it gets the entire request as a string.  Messages
from a ctorrent instance are a single line.
New request types will probably call for a new branch on the
conditional, with a new function to handle them.

Requests that are not implemented yield a warning in the logs, but otherwise
do not hinder the operation of the server.
